L1C4000: db $00
L1C4001: db $00
L1C4002: db $00
L1C4003: db $00
L1C4004: db $00
L1C4005: db $00
L1C4006: db $00
L1C4007: db $00
L1C4008: db $00
L1C4009: db $00
L1C400A: db $00
L1C400B: db $00
L1C400C: db $00
L1C400D: db $00
L1C400E: db $10
L1C400F: db $00
L1C4010: db $2C
L1C4011: db $10
L1C4012: db $2A
L1C4013: db $14
L1C4014: db $1D
L1C4015: db $02
L1C4016: db $7F
L1C4017: db $00
L1C4018: db $9F
L1C4019: db $60
L1C401A: db $7F
L1C401B: db $00
L1C401C: db $0F
L1C401D: db $00
L1C401E: db $09
L1C401F: db $06
L1C4020: db $F3
L1C4021: db $01
L1C4022: db $8B
L1C4023: db $71
L1C4024: db $7F
L1C4025: db $02
L1C4026: db $5F
L1C4027: db $20
L1C4028: db $5F
L1C4029: db $20
L1C402A: db $3E
L1C402B: db $01
L1C402C: db $06
L1C402D: db $01
L1C402E: db $0F
L1C402F: db $04
L1C4030: db $0F
L1C4031: db $07
L1C4032: db $0F
L1C4033: db $03
L1C4034: db $0F
L1C4035: db $06
L1C4036: db $1F
L1C4037: db $0F
L1C4038: db $1F
L1C4039: db $0F
L1C403A: db $1F
L1C403B: db $0E
L1C403C: db $3F
L1C403D: db $1E
L1C403E: db $3F
L1C403F: db $1E
L1C4040: db $11
L1C4041: db $0E
L1C4042: db $11
L1C4043: db $0E
L1C4044: db $17
L1C4045: db $08
L1C4046: db $7F
L1C4047: db $00
L1C4048: db $FF
L1C4049: db $00
L1C404A: db $77
L1C404B: db $08
L1C404C: db $23
L1C404D: db $1C
L1C404E: db $27
L1C404F: db $18
L1C4050: db $2D
L1C4051: db $12
L1C4052: db $74
L1C4053: db $2B
L1C4054: db $70
L1C4055: db $2F
L1C4056: db $E9
L1C4057: db $56
L1C4058: db $E6
L1C4059: db $19
L1C405A: db $FD
L1C405B: db $02
L1C405C: db $C4
L1C405D: db $3B
L1C405E: db $C0
L1C405F: db $3F
L1C4060: db $00
L1C4061: db $00
L1C4062: db $00
L1C4063: db $00
L1C4064: db $80
L1C4065: db $00
L1C4066: db $C0
L1C4067: db $00
L1C4068: db $C0
L1C4069: db $00
L1C406A: db $E0
L1C406B: db $00
L1C406C: db $E0
L1C406D: db $00
L1C406E: db $E0
L1C406F: db $00
L1C4070: db $60
L1C4071: db $80
L1C4072: db $F0
L1C4073: db $20
L1C4074: db $F8
L1C4075: db $70
L1C4076: db $F8
L1C4077: db $F0
L1C4078: db $F8
L1C4079: db $70
L1C407A: db $78
L1C407B: db $B0
L1C407C: db $B0
L1C407D: db $40
L1C407E: db $A0
L1C407F: db $40
L1C4080: db $3F
L1C4081: db $06
L1C4082: db $3E
L1C4083: db $0C
L1C4084: db $3E
L1C4085: db $1C
L1C4086: db $7C
L1C4087: db $38
L1C4088: db $7C
L1C4089: db $38
L1C408A: db $7C
L1C408B: db $38
L1C408C: db $78
L1C408D: db $30
L1C408E: db $78
L1C408F: db $30
L1C4090: db $B8
L1C4091: db $40
L1C4092: db $90
L1C4093: db $60
L1C4094: db $90
L1C4095: db $60
L1C4096: db $90
L1C4097: db $60
L1C4098: db $50
L1C4099: db $20
L1C409A: db $30
L1C409B: db $00
L1C409C: db $00
L1C409D: db $00
L1C409E: db $00
L1C409F: db $00
L1C40A0: db $06
L1C40A1: db $F8
L1C40A2: db $98
L1C40A3: db $60
L1C40A4: db $F0
L1C40A5: db $80
L1C40A6: db $F0
L1C40A7: db $60
L1C40A8: db $F8
L1C40A9: db $70
L1C40AA: db $F8
L1C40AB: db $70
L1C40AC: db $FC
L1C40AD: db $78
L1C40AE: db $FC
L1C40AF: db $B8
L1C40B0: db $FC
L1C40B1: db $F8
L1C40B2: db $FC
L1C40B3: db $78
L1C40B4: db $78
L1C40B5: db $00
L1C40B6: db $00
L1C40B7: db $00
L1C40B8: db $00
L1C40B9: db $00
L1C40BA: db $00
L1C40BB: db $00
L1C40BC: db $00
L1C40BD: db $00
L1C40BE: db $00
L1C40BF: db $00
L1C40C0: db $00
L1C40C1: db $00
L1C40C2: db $00
L1C40C3: db $00
L1C40C4: db $00
L1C40C5: db $00
L1C40C6: db $00
L1C40C7: db $00
L1C40C8: db $00
L1C40C9: db $00
L1C40CA: db $00
L1C40CB: db $00
L1C40CC: db $00
L1C40CD: db $00
L1C40CE: db $00
L1C40CF: db $00
L1C40D0: db $00
L1C40D1: db $00
L1C40D2: db $03
L1C40D3: db $00
L1C40D4: db $0F
L1C40D5: db $03
L1C40D6: db $1E
L1C40D7: db $09
L1C40D8: db $1F
L1C40D9: db $1B
L1C40DA: db $28
L1C40DB: db $3F
L1C40DC: db $53
L1C40DD: db $7E
L1C40DE: db $F3
L1C40DF: db $FC
L1C40E0: db $00
L1C40E1: db $00
L1C40E2: db $01
L1C40E3: db $00
L1C40E4: db $3F
L1C40E5: db $31
L1C40E6: db $FF
L1C40E7: db $1E
L1C40E8: db $EB
L1C40E9: db $F4
L1C40EA: db $CE
L1C40EB: db $70
L1C40EC: db $70
L1C40ED: db $E0
L1C40EE: db $E3
L1C40EF: db $80
L1C40F0: db $C7
L1C40F1: db $80
L1C40F2: db $8F
L1C40F3: db $00
L1C40F4: db $0E
L1C40F5: db $01
L1C40F6: db $1E
L1C40F7: db $01
L1C40F8: db $1E
L1C40F9: db $01
L1C40FA: db $17
L1C40FB: db $00
L1C40FC: db $05
L1C40FD: db $00
L1C40FE: db $00
L1C40FF: db $00
L1C4100: db $01
L1C4101: db $00
L1C4102: db $F7
L1C4103: db $00
L1C4104: db $E6
L1C4105: db $81
L1C4106: db $C7
L1C4107: db $00
L1C4108: db $03
L1C4109: db $00
L1C410A: db $02
L1C410B: db $01
L1C410C: db $E4
L1C410D: db $03
L1C410E: db $F8
L1C410F: db $07
L1C4110: db $FC
L1C4111: db $03
L1C4112: db $B6
L1C4113: db $49
L1C4114: db $3E
L1C4115: db $C1
L1C4116: db $77
L1C4117: db $88
L1C4118: db $CF
L1C4119: db $33
L1C411A: db $47
L1C411B: db $BA
L1C411C: db $0E
L1C411D: db $F5
L1C411E: db $9E
L1C411F: db $65
L1C4120: db $80
L1C4121: db $00
L1C4122: db $C0
L1C4123: db $00
L1C4124: db $40
L1C4125: db $80
L1C4126: db $C0
L1C4127: db $00
L1C4128: db $C0
L1C4129: db $00
L1C412A: db $C0
L1C412B: db $00
L1C412C: db $40
L1C412D: db $80
L1C412E: db $40
L1C412F: db $80
L1C4130: db $40
L1C4131: db $80
L1C4132: db $98
L1C4133: db $00
L1C4134: db $94
L1C4135: db $08
L1C4136: db $1A
L1C4137: db $04
L1C4138: db $AE
L1C4139: db $10
L1C413A: db $7E
L1C413B: db $80
L1C413C: db $9E
L1C413D: db $60
L1C413E: db $92
L1C413F: db $6C
L1C4140: db $66
L1C4141: db $3C
L1C4142: db $7C
L1C4143: db $78
L1C4144: db $EC
L1C4145: db $78
L1C4146: db $F8
L1C4147: db $70
L1C4148: db $68
L1C4149: db $30
L1C414A: db $C8
L1C414B: db $B0
L1C414C: db $6C
L1C414D: db $38
L1C414E: db $6C
L1C414F: db $38
L1C4150: db $24
L1C4151: db $18
L1C4152: db $24
L1C4153: db $18
L1C4154: db $14
L1C4155: db $08
L1C4156: db $1A
L1C4157: db $14
L1C4158: db $0E
L1C4159: db $04
L1C415A: db $06
L1C415B: db $04
L1C415C: db $03
L1C415D: db $00
L1C415E: db $01
L1C415F: db $00
L1C4160: db $6E
L1C4161: db $15
L1C4162: db $47
L1C4163: db $3A
L1C4164: db $43
L1C4165: db $3D
L1C4166: db $21
L1C4167: db $1E
L1C4168: db $10
L1C4169: db $0F
L1C416A: db $1F
L1C416B: db $00
L1C416C: db $FF
L1C416D: db $07
L1C416E: db $FF
L1C416F: db $FB
L1C4170: db $FF
L1C4171: db $FF
L1C4172: db $FF
L1C4173: db $7E
L1C4174: db $FF
L1C4175: db $81
L1C4176: db $FF
L1C4177: db $E7
L1C4178: db $FF
L1C4179: db $E5
L1C417A: db $F7
L1C417B: db $E2
L1C417C: db $F7
L1C417D: db $43
L1C417E: db $4F
L1C417F: db $33
L1C4180: db $82
L1C4181: db $7C
L1C4182: db $52
L1C4183: db $AC
L1C4184: db $EC
L1C4185: db $00
L1C4186: db $F0
L1C4187: db $E0
L1C4188: db $F0
L1C4189: db $20
L1C418A: db $B8
L1C418B: db $10
L1C418C: db $D8
L1C418D: db $80
L1C418E: db $C8
L1C418F: db $80
L1C4190: db $C0
L1C4191: db $80
L1C4192: db $80
L1C4193: db $00
L1C4194: db $C0
L1C4195: db $80
L1C4196: db $C0
L1C4197: db $80
L1C4198: db $C0
L1C4199: db $80
L1C419A: db $C0
L1C419B: db $80
L1C419C: db $C0
L1C419D: db $00
L1C419E: db $E0
L1C419F: db $C0
L1C41A0: db $7F
L1C41A1: db $9A
L1C41A2: db $9F
L1C41A3: db $0C
L1C41A4: db $1F
L1C41A5: db $0E
L1C41A6: db $0F
L1C41A7: db $06
L1C41A8: db $0F
L1C41A9: db $04
L1C41AA: db $0D
L1C41AB: db $02
L1C41AC: db $09
L1C41AD: db $06
L1C41AE: db $12
L1C41AF: db $0C
L1C41B0: db $14
L1C41B1: db $08
L1C41B2: db $18
L1C41B3: db $00
L1C41B4: db $00
L1C41B5: db $00
L1C41B6: db $00
L1C41B7: db $00
L1C41B8: db $00
L1C41B9: db $00
L1C41BA: db $00
L1C41BB: db $00
L1C41BC: db $00
L1C41BD: db $00
L1C41BE: db $00
L1C41BF: db $00
L1C41C0: db $1F
L1C41C1: db $07
L1C41C2: db $3F
L1C41C3: db $1F
L1C41C4: db $3F
L1C41C5: db $1B
L1C41C6: db $1F
L1C41C7: db $0C
L1C41C8: db $1F
L1C41C9: db $0F
L1C41CA: db $0F
L1C41CB: db $07
L1C41CC: db $0F
L1C41CD: db $07
L1C41CE: db $07
L1C41CF: db $02
L1C41D0: db $02
L1C41D1: db $01
L1C41D2: db $04
L1C41D3: db $03
L1C41D4: db $05
L1C41D5: db $02
L1C41D6: db $0B
L1C41D7: db $04
L1C41D8: db $0C
L1C41D9: db $00
L1C41DA: db $00
L1C41DB: db $00
L1C41DC: db $00
L1C41DD: db $00
L1C41DE: db $00
L1C41DF: db $00
L1C41E0: db $11
L1C41E1: db $0E
L1C41E2: db $27
L1C41E3: db $18
L1C41E4: db $42
L1C41E5: db $3D
L1C41E6: db $45
L1C41E7: db $3A
L1C41E8: db $35
L1C41E9: db $0A
L1C41EA: db $0F
L1C41EB: db $00
L1C41EC: db $01
L1C41ED: db $00
L1C41EE: db $00
L1C41EF: db $00
L1C41F0: db $00
L1C41F1: db $00
L1C41F2: db $01
L1C41F3: db $00
L1C41F4: db $03
L1C41F5: db $01
L1C41F6: db $03
L1C41F7: db $00
L1C41F8: db $00
L1C41F9: db $00
L1C41FA: db $00
L1C41FB: db $00
L1C41FC: db $00
L1C41FD: db $00
L1C41FE: db $00
L1C41FF: db $00
L1C4200: db $01
L1C4201: db $00
L1C4202: db $3B
L1C4203: db $00
L1C4204: db $77
L1C4205: db $08
L1C4206: db $FF
L1C4207: db $00
L1C4208: db $FB
L1C4209: db $00
L1C420A: db $13
L1C420B: db $E0
L1C420C: db $7F
L1C420D: db $81
L1C420E: db $2E
L1C420F: db $D7
L1C4210: db $5E
L1C4211: db $AF
L1C4212: db $5C
L1C4213: db $AF
L1C4214: db $FE
L1C4215: db $0F
L1C4216: db $1E
L1C4217: db $0F
L1C4218: db $0F
L1C4219: db $06
L1C421A: db $0F
L1C421B: db $01
L1C421C: db $1F
L1C421D: db $0F
L1C421E: db $3F
L1C421F: db $10
L1C4220: db $3E
L1C4221: db $00
L1C4222: db $FC
L1C4223: db $00
L1C4224: db $FE
L1C4225: db $00
L1C4226: db $CF
L1C4227: db $30
L1C4228: db $E6
L1C4229: db $18
L1C422A: db $9F
L1C422B: db $60
L1C422C: db $FD
L1C422D: db $1A
L1C422E: db $FA
L1C422F: db $F5
L1C4230: db $FA
L1C4231: db $F5
L1C4232: db $3A
L1C4233: db $F5
L1C4234: db $CD
L1C4235: db $FA
L1C4236: db $DE
L1C4237: db $FC
L1C4238: db $7E
L1C4239: db $C8
L1C423A: db $FA
L1C423B: db $34
L1C423C: db $F4
L1C423D: db $C8
L1C423E: db $C4
L1C423F: db $38
L1C4240: db $00
L1C4241: db $00
L1C4242: db $00
L1C4243: db $00
L1C4244: db $00
L1C4245: db $00
L1C4246: db $00
L1C4247: db $00
L1C4248: db $00
L1C4249: db $00
L1C424A: db $1E
L1C424B: db $00
L1C424C: db $3F
L1C424D: db $00
L1C424E: db $5B
L1C424F: db $24
L1C4250: db $3F
L1C4251: db $00
L1C4252: db $13
L1C4253: db $0C
L1C4254: db $A2
L1C4255: db $1C
L1C4256: db $42
L1C4257: db $BC
L1C4258: db $62
L1C4259: db $9C
L1C425A: db $0C
L1C425B: db $F0
L1C425C: db $30
L1C425D: db $C0
L1C425E: db $C0
L1C425F: db $00
L1C4260: db $CF
L1C4261: db $30
L1C4262: db $FF
L1C4263: db $0F
L1C4264: db $FF
L1C4265: db $6F
L1C4266: db $FF
L1C4267: db $6E
L1C4268: db $FF
L1C4269: db $31
L1C426A: db $FF
L1C426B: db $4B
L1C426C: db $FF
L1C426D: db $79
L1C426E: db $FD
L1C426F: db $78
L1C4270: db $FD
L1C4271: db $78
L1C4272: db $F9
L1C4273: db $70
L1C4274: db $FB
L1C4275: db $11
L1C4276: db $F3
L1C4277: db $20
L1C4278: db $FA
L1C4279: db $71
L1C427A: db $FB
L1C427B: db $70
L1C427C: db $F9
L1C427D: db $70
L1C427E: db $79
L1C427F: db $30
L1C4280: db $F8
L1C4281: db $F0
L1C4282: db $F8
L1C4283: db $F0
L1C4284: db $FC
L1C4285: db $E8
L1C4286: db $FE
L1C4287: db $1C
L1C4288: db $FE
L1C4289: db $BC
L1C428A: db $FF
L1C428B: db $9E
L1C428C: db $DF
L1C428D: db $80
L1C428E: db $DF
L1C428F: db $8E
L1C4290: db $9F
L1C4291: db $0E
L1C4292: db $BE
L1C4293: db $1C
L1C4294: db $3E
L1C4295: db $00
L1C4296: db $A4
L1C4297: db $18
L1C4298: db $BA
L1C4299: db $04
L1C429A: db $9E
L1C429B: db $00
L1C429C: db $9E
L1C429D: db $00
L1C429E: db $8E
L1C429F: db $00
L1C42A0: db $0F
L1C42A1: db $06
L1C42A2: db $0F
L1C42A3: db $00
L1C42A4: db $09
L1C42A5: db $06
L1C42A6: db $17
L1C42A7: db $08
L1C42A8: db $1E
L1C42A9: db $00
L1C42AA: db $1E
L1C42AB: db $00
L1C42AC: db $1C
L1C42AD: db $00
L1C42AE: db $00
L1C42AF: db $00
L1C42B0: db $00
L1C42B1: db $00
L1C42B2: db $00
L1C42B3: db $00
L1C42B4: db $00
L1C42B5: db $00
L1C42B6: db $00
L1C42B7: db $00
L1C42B8: db $00
L1C42B9: db $00
L1C42BA: db $00
L1C42BB: db $00
L1C42BC: db $00
L1C42BD: db $00
L1C42BE: db $00
L1C42BF: db $00
L1C42C0: db $00
L1C42C1: db $00
L1C42C2: db $00
L1C42C3: db $00
L1C42C4: db $01
L1C42C5: db $00
L1C42C6: db $02
L1C42C7: db $01
L1C42C8: db $03
L1C42C9: db $00
L1C42CA: db $01
L1C42CB: db $00
L1C42CC: db $02
L1C42CD: db $01
L1C42CE: db $01
L1C42CF: db $00
L1C42D0: db $00
L1C42D1: db $00
L1C42D2: db $00
L1C42D3: db $00
L1C42D4: db $01
L1C42D5: db $00
L1C42D6: db $03
L1C42D7: db $00
L1C42D8: db $07
L1C42D9: db $00
L1C42DA: db $03
L1C42DB: db $00
L1C42DC: db $03
L1C42DD: db $00
L1C42DE: db $02
L1C42DF: db $00
L1C42E0: db $80
L1C42E1: db $00
L1C42E2: db $40
L1C42E3: db $80
L1C42E4: db $F0
L1C42E5: db $00
L1C42E6: db $58
L1C42E7: db $A0
L1C42E8: db $FE
L1C42E9: db $00
L1C42EA: db $39
L1C42EB: db $06
L1C42EC: db $70
L1C42ED: db $0F
L1C42EE: db $F8
L1C42EF: db $07
L1C42F0: db $FC
L1C42F1: db $03
L1C42F2: db $BE
L1C42F3: db $41
L1C42F4: db $9E
L1C42F5: db $61
L1C42F6: db $B7
L1C42F7: db $48
L1C42F8: db $D3
L1C42F9: db $2D
L1C42FA: db $C3
L1C42FB: db $3D
L1C42FC: db $25
L1C42FD: db $1A
L1C42FE: db $19
L1C42FF: db $06
L1C4300: db $80
L1C4301: db $00
L1C4302: db $40
L1C4303: db $80
L1C4304: db $60
L1C4305: db $80
L1C4306: db $50
L1C4307: db $A0
L1C4308: db $9E
L1C4309: db $60
L1C430A: db $11
L1C430B: db $EE
L1C430C: db $39
L1C430D: db $D6
L1C430E: db $FB
L1C430F: db $34
L1C4310: db $FD
L1C4311: db $72
L1C4312: db $FA
L1C4313: db $B4
L1C4314: db $FE
L1C4315: db $C8
L1C4316: db $FC
L1C4317: db $78
L1C4318: db $FC
L1C4319: db $78
L1C431A: db $78
L1C431B: db $B0
L1C431C: db $FC
L1C431D: db $28
L1C431E: db $FC
L1C431F: db $98
L1C4320: db $1C
L1C4321: db $03
L1C4322: db $3E
L1C4323: db $01
L1C4324: db $3A
L1C4325: db $01
L1C4326: db $67
L1C4327: db $01
L1C4328: db $1F
L1C4329: db $05
L1C432A: db $7F
L1C432B: db $1E
L1C432C: db $FF
L1C432D: db $7D
L1C432E: db $FF
L1C432F: db $FB
L1C4330: db $FF
L1C4331: db $D3
L1C4332: db $F7
L1C4333: db $C3
L1C4334: db $F3
L1C4335: db $E1
L1C4336: db $E3
L1C4337: db $C0
L1C4338: db $E1
L1C4339: db $C0
L1C433A: db $C0
L1C433B: db $80
L1C433C: db $80
L1C433D: db $00
L1C433E: db $80
L1C433F: db $00
L1C4340: db $FC
L1C4341: db $78
L1C4342: db $F8
L1C4343: db $F0
L1C4344: db $F8
L1C4345: db $F0
L1C4346: db $F0
L1C4347: db $C0
L1C4348: db $E0
L1C4349: db $80
L1C434A: db $F0
L1C434B: db $A0
L1C434C: db $F0
L1C434D: db $E0
L1C434E: db $F8
L1C434F: db $F0
L1C4350: db $FC
L1C4351: db $70
L1C4352: db $74
L1C4353: db $08
L1C4354: db $44
L1C4355: db $38
L1C4356: db $78
L1C4357: db $00
L1C4358: db $00
L1C4359: db $00
L1C435A: db $00
L1C435B: db $00
L1C435C: db $00
L1C435D: db $00
L1C435E: db $00
L1C435F: db $00
L1C4360: db $01
L1C4361: db $00
L1C4362: db $01
L1C4363: db $00
L1C4364: db $01
L1C4365: db $00
L1C4366: db $03
L1C4367: db $01
L1C4368: db $03
L1C4369: db $01
L1C436A: db $07
L1C436B: db $03
L1C436C: db $07
L1C436D: db $00
L1C436E: db $08
L1C436F: db $07
L1C4370: db $10
L1C4371: db $0F
L1C4372: db $1F
L1C4373: db $00
L1C4374: db $00
L1C4375: db $00
L1C4376: db $00
L1C4377: db $00
L1C4378: db $00
L1C4379: db $00
L1C437A: db $00
L1C437B: db $00
L1C437C: db $00
L1C437D: db $00
L1C437E: db $00
L1C437F: db $00

; 
; =============== START OF MODULE TitleMenu ===============
;
; =============== Module_Title ===============
; EntryPoint for Title Screen and Menus. Called by rst $00 jump from Module_Intro.
L1C4380:
Module_Title:
	ld   sp, $DD00
	di
	;-----------------------------------
	rst  $10				; Stop LCD
	call DisableSectLYC
	ld   hl, wMisc_C028
	res  MISCB_PL_RANGE_CHECK, [hl]
	set  MISCB_TITLE_SECT, [hl]			; Enable title parallax mode
	
	; Init vars
	xor  a
	ldh  [rBGP], a
	ldh  [rOBP0], a
	ldh  [rOBP1], a
	ld   [wTitleMode], a
	ld   [wJoyActivePl], a
	ld   [wTitleMenuOptId], a
	ld   [wTitleMenuCursorXBak], a
	ld   [wTitleMenuCursorYBak], a
	ld   [wTitleSubMenuOptId], a
	ld   [wOptionsSGBSndOptId], a
	ld   [wOptionsBGMId], a
	ld   [wOptionsSFXId], a
	ld   [wOptionsMenuMode], a
	ld   [wTitleBlinkTimer], a
	ld   [wOptionsSGBSndIdA], a
	ld   [wOptionsSGBSndBankA], a
	ld   [wOptionsSGBSndIdB], a
	ld   [wOptionsSGBSndBankB], a
	ld   [wTitleParallaxBaseSpeed], a
	ld   [wTitleParallaxBaseSpeedSub], a
	
	; After 30 seconds of inactivity in GM_TITLE_TITLE, return to the intro
	ld   a, HIGH(TITLE_RESET_TIMER)
	ld   [wTitleResetTimer_High], a
	ld   a, LOW(TITLE_RESET_TIMER)
	ld   [wTitleResetTimer_Low], a
	
	; Copy the SGB packet used to play audio in the SGB Sound Test at the start of the LZSS Buffer.
	; This will take up $10 bytes, and cause the actual LZSS buffer in the module to start $10 bytes after.
	ld   hl, SGBPacketDef_Options_PlaySnd
	ldi  a, [hl]					; B = Bytes to copy
	ld   b, a						
	ld   de, wOptionsSGBPacketSnd	; DE = Target
	; The remaining bytes are copied into the buffer
.cpLoop:
	ldi  a, [hl]			
	ld   [de], a			
	inc  de
	dec  b					; Are we done?
	jp   nz, .cpLoop		; If not, loop
	
	; Load SGB palettes
	ld   de, SCRPAL_TITLE
	call HomeCall_SGB_ApplyScreenPalSet
	
	; Clear tilemaps
	call ClearBGMap
	call ClearWINDOWMap
	
	; Init scroll positions for BG layer, used for the parallax clouds
	xor  a
	ldh  [hScrollX], a
	ldh  [hTitleParallax1X], a
	ldh  [hTitleParallax2X], a
	ldh  [hTitleParallax3X], a
	ldh  [hTitleParallax4X], a
	ldh  [hTitleParallax5X], a
	ld   [wOBJScrollX], a
	ld   a, $00
	ld   [wOBJScrollY], a
	ld   a, $7C
	ldh  [hScrollY], a
	
	; FarCall to self bank... did it use to be elsewhere?
	ld   b, BANK(Title_LoadVRAM) ; BANK $1C
	ld   hl, Title_LoadVRAM
	rst  $08
	
	;
	; Write the menu text in the BG layer.
	;
	; Because the BG layer only contains a 3-tiles tall horizontal strip, there's enough space
	; to generate both text-only menu screens.
	; The tilemap won't be touched again when navigating through the title screen/menus,
	; only the graphics will be reloaded.
	;
	
	ld   hl, TextDef_Menu_Title
	call TextPrinter_Instant
	ld   hl, TextDef_Menu_SinglePlay
	call TextPrinter_Instant
	ld   hl, TextDef_Menu_TeamPlay
	call TextPrinter_Instant
	ld   hl, TextDef_Menu_SingleVS
	call TextPrinter_Instant
	ld   hl, TextDef_Menu_TeamVS
	call TextPrinter_Instant
	ld   hl, TextDef_Options_Title
	call TextPrinter_Instant
	ld   hl, TextDef_Options_Time
	call TextPrinter_Instant
	ld   hl, TextDef_Options_Level
	call TextPrinter_Instant
	ld   hl, TextDef_Options_BGMTest
	call TextPrinter_Instant
	ld   hl, TextDef_Options_SFXTest
	call TextPrinter_Instant
	ld   hl, TextDef_Options_Exit
	call TextPrinter_Instant
	
	; If dip switches are set, display the dip value and any extra options
	ld   a, [wDipSwitch]
	or   a						; Any dip switch set?
	jp   z, .noDip				; If not, skip
	ld   hl, TextDef_Options_Dip
	call TextPrinter_Instant
.noDip:
	; Print text for SGB sound test
	ld   a, [wMisc_C025]
	bit  MISCB_IS_SGB, a		; Running on a SGB?
	jp   z, .initOBJ			; If not, skip
	ld   a, [wDipSwitch]
	bit  DIPB_SGB_SOUND_TEST, a	; SGB sound test enabled?
	jp   z, .initOBJ			; If not, skip
	
	ld   hl, TextDef_Options_SGBSndTest
	call TextPrinter_Instant
	ld   hl, TextDef_Options_SGBSndTypes
	call TextPrinter_Instant
	ld   hl, TextDef_Options_SGBSndPlaceholders
	call TextPrinter_Instant
.initOBJ:
	;
	; Prepare sprites.
	; These all use OBJLstPtrTable_Title, with different offsets.
	;
	
	call ClearOBJInfo
	
	; OBJ2 - (C)SNK 1996 text
	ld   hl, wOBJInfo_SnkText+iOBJInfo_Status
	ld   de, OBJInfoInit_Title
	call OBJLstS_InitFrom
	ld   hl, wOBJInfo_SnkText+iOBJInfo_X
	ld   [hl], $34
	ld   hl, wOBJInfo_SnkText+iOBJInfo_Y
	ld   [hl], $48
	ld   hl, wOBJInfo_SnkText+iOBJInfo_OBJLstPtrTblOffset
	ld   [hl], TITLE_OBJ_SNKCOPYRIGHT*OBJLSTPTR_ENTRYSIZE
	
	; OBJ1 - Title screen menu text (PUSH START, ...)
	ld   hl, wOBJInfo_MenuText+iOBJInfo_Status
	ld   de, OBJInfoInit_Title
	call OBJLstS_InitFrom
	ld   hl, wOBJInfo_MenuText+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	ld   hl, wOBJInfo_MenuText+iOBJInfo_X
	ld   [hl], $28
	ld   hl, wOBJInfo_MenuText+iOBJInfo_Y
	ld   [hl], $43
	; Entry $00
	
	; OBJ0 - Cursor pointing right
	ld   hl, wOBJInfo_CursorR+iOBJInfo_Status
	ld   de, OBJInfoInit_Title
	call OBJLstS_InitFrom
	ld   hl, wOBJInfo_CursorR+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	ld   hl, wOBJInfo_CursorR+iOBJInfo_X
	ld   [hl], $28
	ld   hl, wOBJInfo_CursorR+iOBJInfo_Y
	ld   [hl], $43
	ld   hl, wOBJInfo_CursorR+iOBJInfo_OBJLstPtrTblOffset
	ld   [hl], TITLE_OBJ_CURSOR_R*OBJLSTPTR_ENTRYSIZE
	
	; OBJ3 - Cursor pointing up (for SGB Sound Test)
	ld   hl, wOBJInfo_CursorU+iOBJInfo_Status
	ld   de, OBJInfoInit_Title
	call OBJLstS_InitFrom
	ld   hl, wOBJInfo_CursorU+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	ld   hl, wOBJInfo_CursorU+iOBJInfo_X
	ld   [hl], $50
	ld   hl, wOBJInfo_CursorU+iOBJInfo_Y
	ld   [hl], $60
	ld   hl, wOBJInfo_CursorU+iOBJInfo_OBJLstPtrTblOffset
	ld   [hl], TITLE_OBJ_CURSOR_U*OBJLSTPTR_ENTRYSIZE
	
	; Put WINDOW over BG
	xor  a
	ldh  [rWY], a
	ld   a, $07
	ldh  [rWX], a
	
	ld   a, LCDC_PRIORITY|LCDC_OBJENABLE|LCDC_OBJSIZE|LCDC_WENABLE|LCDC_WTILEMAP|LCDC_ENABLE
	rst  $18				; Resume LCD
	;-----------------------------------
	
	; Enable LYC, start parallax at line $66
	ldh  a, [rSTAT]
	or   a, STAT_LYC
	ldh  [rSTAT], a
	ld   a, $66
	ldh  [rLYC], a
	ldh  a, [rIE]
	or   a, I_STAT|I_VBLANK
	ldh  [rIE], a
	
	ei
	
	call Task_PassControl_NoDelay
	
	; Load DMG palettes
	ld   a, $3F
	ldh  [rOBP0], a
	ld   a, $00
	ldh  [rOBP1], a
	ld   a, $1B
	ldh  [rBGP], a
	
	; Stop music
	ld   a, SND_MUTE
	call HomeCall_Sound_ReqPlayExId_Stub
	
	; Disable serial since the game shouldn't process the other GB inputs on the menu
	; (outside of when a VS mode is selected)
	call Title_DisableSerial
	
.mainLoop:
	call JoyKeys_DoCursorDelayTimer
	call .execMode
	call Task_PassControl_NoDelay
	jp   .mainLoop
.execMode:
	; DynJump for title screen mode
	ld   hl, Title_ModePtrTable	; HL = Title_ModePtrTable
	ld   d, $00
	ld   a, [wTitleMode]		; DE = wTitleMode
	ld   e, a
	add  hl, de					; Offset the table
	ld   e, [hl]				; Read out jump target to DE
	inc  hl
	ld   d, [hl]
	push de
	pop  hl						; Move to HL and jump there
	jp   hl
	
Title_ModePtrTable:
	dw Title_Mode_TitleScreen
	dw Title_Mode_TitleMenu
	dw Title_Mode_ModeSelect
	dw Title_Mode_Options
	
; =============== Title_Mode_TitleScreen ===============
; Title screen - Initial mode.
Title_Mode_TitleScreen:
	call TitleScreen_CheckReset
	call TitleScreen_BlinkPushStartText
	call Title_UpdateParallaxCoords
	call TitleScreen_IsStartPressed ; Pressed START?
	jp   c, .switchToTitleMenu ; If so, jump
	ret
.switchToTitleMenu:
	;
	; Activate the GAME START/OPTIONS menu on the title screen
	;
	ld   a, GM_TITLE_TITLEMENU		; Next mode
	ld   [wTitleMode], a
	ld   a, $00						; Select GAME START
	ld   [wTitleMenuOptId], a
	
	; Display cursor
	ld   hl, wOBJInfo_CursorR+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]
	ld   hl, wOBJInfo_CursorR+iOBJInfo_Y
	ld   [hl], $43
	
	; Change OBJLst id to GAME START/OPTIONS text
	ld   hl, wOBJInfo_MenuText+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]
	ld   hl, wOBJInfo_MenuText+iOBJInfo_OBJLstPtrTblOffset
	ld   [hl], TITLE_OBJ_MENU*OBJLSTPTR_ENTRYSIZE
	ret
	
; =============== TitleScreen_CheckReset ===============
; Checks if enough time has passed without pressing START.
; If enough frames have passed, reset to the intro.
TitleScreen_CheckReset:
	; wTitleResetTimer--
	ld   hl, wTitleResetTimer_Low	
	dec  [hl]							; Decrement low byte
	jp   nz, .ret						; Is it 0 now? If not, return
	ld   [hl], LOW(TITLE_RESET_TIMER)	; Reset to 60 frames
	ld   hl, wTitleResetTimer_High	
	dec  [hl]							; Decrement high byte
	jp   nz, .ret						; Is it 0 now? If not, return
	
	; If we got here, wTitleResetTimer_Low and wTitleResetTimer_High are 0.
	; Return to the TAKARA logo.
	xor  a
	ldh  [rBGP], a
	ldh  [rOBP0], a
	ldh  [rOBP1], a
	ld   b, BANK(Module_TakaraLogo) ; BANK $0A
	ld   hl, Module_TakaraLogo
	rst  $00
.ret:
	ret
	
; =============== Title_Mode_TitleMenu ===============
; Title screen - Menu.
Title_Mode_TitleMenu:
	call Title_BlinkCursorR
	call Title_UpdateParallaxCoords
	call TitleMenu_DoCtrl
	ret  nc	; If we're not switching (C flag clear), return
	
	cp   TITLEMENU_TO_TITLE
	jp   z, .toTitle
	cp   TITLEMENU_TO_MODESELECT
	jp   z, .toModeSelect
	cp   TITLEMENU_TO_OPTIONS
	jp   z, .toOptions
	ret ; We never get here
	
.toTitle:
	;
	; Return back to PUSH START prompt
	;
	ld   a, GM_TITLE_TITLE			
	ld   [wTitleMode], a
	ld   a, HIGH(TITLE_RESET_TIMER)	
	ld   [wTitleResetTimer_High], a
	ld   a, LOW(TITLE_RESET_TIMER)
	ld   [wTitleResetTimer_Low], a
	
	; Hide cursor
	ld   hl, wOBJInfo_CursorR+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	; Switch to PUSH START text
	ld   hl, wOBJInfo_MenuText+iOBJInfo_OBJLstPtrTblOffset
	ld   [hl], TITLE_OBJ_PUSHSTART
	ret
	
.toModeSelect:
	
	call Title_DisableSerial
	
	; Reset pal
	ld   a, $FF
	ldh  [rBGP], a
	ldh  [rOBP0], a
	ldh  [rOBP1], a
	
	; Start over SINGLE PLAY
	ld   a, $00
	ld   [wTitleSubMenuOptId], a
	
	; Next mode
	ld   a, GM_TITLE_MODESELECT
	ld   [wTitleMode], a
	
	; Set the BG scroll to where the mode select text is
	xor  a
	ldh  [hScrollX], a
	ldh  [hTitleParallax1X], a
	ldh  [hTitleParallax2X], a
	ldh  [hTitleParallax3X], a
	ldh  [hTitleParallax4X], a
	ldh  [hTitleParallax5X], a
	ld   a, $20
	ldh  [hScrollY], a
	
	; Move cursor sprite down 8px by pretending the screen is scrolled up by 8px.
	;
	; We aren't using sections in menus so the BG is unaffected, 
	; but the sprite mapping writer still takes this into consideration.
	ld   a, -$08					
	ld   [wOBJScrollY], a
	
	; Save current cursor location
	ld   a, [wOBJInfo_CursorR+iOBJInfo_X]
	ld   [wTitleMenuCursorXBak], a
	ld   a, [wOBJInfo_CursorR+iOBJInfo_Y]
	ld   [wTitleMenuCursorYBak], a
	
	jp   .initMenu
.toOptions:

	; Reset pal
	ld   a, $FF
	ldh  [rBGP], a
	ldh  [rOBP0], a
	ldh  [rOBP1], a
	
	; Reset cursor pos
	ld   a, $00
	ld   [wTitleSubMenuOptId], a
	ld   [wOptionsSGBSndOptId], a
	ld   [wOptionsMenuMode], a
	ld   [wOptionsBGMId], a
	ld   [wOptionsSFXId], a
	
	; Next mode
	ld   a, GM_TITLE_OPTIONS
	ld   [wTitleMode], a
	
	; Set the BG scroll to where the option menu text is
	ld   a, $80
	ldh  [hScrollX], a
	ld   a, $20
	ldh  [hScrollY], a
	ld   a, $08					; ???
	ld   [wOBJScrollY], a
	
	; Save current cursor location
	ld   a, [wOBJInfo_CursorR+iOBJInfo_X]
	ld   [wTitleMenuCursorXBak], a
	ld   a, [wOBJInfo_CursorR+iOBJInfo_Y]
	ld   [wTitleMenuCursorYBak], a
	
	; Print the current option values
	call Options_PrintMatchTime
	call Options_PrintDifficulty
	call Options_PrintBGMId
	call Options_PrintSFXId
	call Options_PrintSGBSndTestVals
	call Options_PrintDipSwitch
.initMenu:

	;
	; Common menu loader
	;

	; Menu options start at the same X position
	; The screen scrolling and text positions must account for this and be aligned perfectly.
	ld   a, $20
	ld   [wOBJInfo_CursorR+iOBJInfo_X], a
	ld   a, $00
	ld   [wOBJInfo_CursorR+iOBJInfo_Y], a
	
	; Show horizontal cursor
	ld   hl, wOBJInfo_CursorR+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]
	; Hide title screen menu & SNK copyright
	ld   hl, wOBJInfo_MenuText+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	ld   hl, wOBJInfo_SnkText+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	
	; Disable title screen parallax
	ld   hl, wMisc_C028
	res  MISCB_TITLE_SECT, [hl]		; Disable parallax mode
	xor  a
	ldh  [rSTAT], a					; Disable LYC
	
	; Load generic font
	call LoadGFX_1bppFont_Default
	
	; Disable WINDOW
	ld   a, LCDC_PRIORITY|LCDC_OBJENABLE|LCDC_OBJSIZE|LCDC_WTILEMAP|LCDC_ENABLE
	rst  $18				; Resume LCD
	;-----------------------------------
	
	call Task_PassControl_NoDelay
	
	; Load palettes.
	; Note that the SGB palette configuration remains the same as the title screen.
	ld   a, $3F
	ldh  [rOBP0], a
	ld   a, $00
	ldh  [rOBP1], a
	ld   a, $1B
	ldh  [rBGP], a
	ret
	
; =============== TitleMenu_DoCtrl ===============
; Checks for player input in the title screen menu.
; OUT
; - C flag: If set, the game should transition to another submode.
; - A: Determines the new mode (TITLEMENU_TO_*)
TitleMenu_DoCtrl:
	call Title_GetMenuInput
	bit  KEYB_DOWN, b
	jp   nz, .moveV
	bit  KEYB_UP, b
	jp   nz, .moveV
	bit  KEYB_LEFT, b
	jp   nz, .incParallaxSpeed
	bit  KEYB_RIGHT, b
	jp   nz, .decParallaxSpeed
	bit  KEYB_START, a
	jp   nz, .enter
	bit  KEYB_SELECT, a
	jp   nz, .exit
	bit  KEYB_A, a
	jp   nz, .enter
	xor  a
	ret
	
; [POI] Secret.
;       Hold right or left to change cloud speed.
.incParallaxSpeed:
	ld   hl, wTitleParallaxBaseSpeed
	ld   bc, $0008
	call Title_AddWithSubpixels
	xor  a
	ret
.decParallaxSpeed:
	ld   hl, wTitleParallaxBaseSpeed
	ld   bc, -$0008
	call Title_AddWithSubpixels
	xor  a
	ret
.moveV:
	;--
	; Not necessary
	ld   hl, wOBJInfo_CursorR+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]
	;--
	
	; Change selected option
	; Because there are only two menu options, a xor is all that's needed
	ld   a, [wTitleMenuOptId]
	xor  $01
	ld   [wTitleMenuOptId], a
	
	; Move the cursor 8px up or down depending on the new selected option
	cp   TITLEMENU_TO_MODESELECT-1		; wTitleMenuOptId == 0?
	jp   z, .modeSelect					; If so, jump
.options:
	ld   a, [wOBJInfo_CursorR+iOBJInfo_Y]	; Low option, move down
	add  a, $08
	ld   [wOBJInfo_CursorR+iOBJInfo_Y], a
	xor  a
	ret
.modeSelect:
	ld   a, [wOBJInfo_CursorR+iOBJInfo_Y]	; High option, move up
	sub  a, $08
	ld   [wOBJInfo_CursorR+iOBJInfo_Y], a
	xor  a
	ret
.enter:
	; RetVal = wTitleMenuOptId+1
	; Will be TITLEMENU_TO_MODESELECT or TITLEMENU_TO_OPTIONS
	ld   a, [wTitleMenuOptId]
	inc  a
	scf			; Change mode
	ret
.exit:
	ld   a, TITLEMENU_TO_TITLE
	scf			; Change mode
	ret
	
; =============== Title_Mode_ModeSelect ===============
; Mode selection menu.
Title_Mode_ModeSelect:
	call ModeSelect_SetSerialIdle	; Every time so the GBs are always ready to listen to each other.
	call Title_BlinkCursorR
	call ModeSelect_DoCtrl
	jr   nc, .checkOtherPl			; No action returned? If so, jump
.chkAct:
	cp   MODESELECT_ACT_EXIT
	jp   z, TitleSubMenu_Exit
	cp   MODESELECT_ACT_SINGLE1P
	jp   z, .single1P
	cp   MODESELECT_ACT_TEAM1P
	jp   z, .team1P
	cp   MODESELECT_ACT_SINGLEVS
	jp   z, .singleVS
	cp   MODESELECT_ACT_TEAMVS
	jp   z, .teamVS
	ret ; We never get here
.checkOtherPl:
	; Check if the other player (over serial only) sent us a mode id value.
	; If so, start the mode directly.
	call ModeSelect_GetCtrlFromSerial
	cp   MODESELECT_SBCMD_TEAMVS
	jp   z, .startTeamVS
	cp   MODESELECT_SBCMD_SINGLEVS
	jp   z, .startSingleVS
	ret
	
.single1P:
	; 1P Modes don't need special checks
	ld   a, MODE_SINGLE1P
	ld   [wPlayMode], a
	jp   ModeSelect_PrepSingle
.team1P:
	ld   a, MODE_TEAM1P
	ld   [wPlayMode], a
	jp   ModeSelect_PrepSingle
	
.singleVS:
	;
	; Verify that there's a second player
	;
	ld   a, [wMisc_C025]
	bit  MISCB_IS_SGB, a		; Playing on SGB?
	jp   nz, .startSingleVS		; If so, skip the serial checks
	
	; [Master 1/3] Send out VS mode option
	ld   a, MODESELECT_SBCMD_SINGLEVS
	call ModeSelect_Serial_SendAndWait
	; Try to send the rest for sync
	call ModeSelect_TrySendVSData
	cp   MODESELECT_SBCMD_IDLE		; Did the other GB listen to the original request? 
	jr   z, .startSingleVS			; If so, jump
	ld   a, SFX_GAMEOVER
	jp   HomeCall_Sound_ReqPlayExId
.startSingleVS:
	ld   a, MODE_SINGLEVS
	ld   [wPlayMode], a
	jp   ModeSelect_PrepVS
	
.teamVS:
	ld   a, [wMisc_C025]
	bit  MISCB_IS_SGB, a		; Playing on SGB?
	jp   nz, .startTeamVS		; If so, skip the serial checks
	; [Master 1/3] Send out VS mode option
	ld   a, MODESELECT_SBCMD_TEAMVS
	call ModeSelect_Serial_SendAndWait
	; Try to send the rest for sync
	call ModeSelect_TrySendVSData
	cp   MODESELECT_SBCMD_IDLE		; Did the other GB listen to the original request? 
	jr   z, .startTeamVS			; If so, jump
	; Otherwise, play an error sound
	ld   a, SFX_GAMEOVER
	jp   HomeCall_Sound_ReqPlayExId
.startTeamVS: 
	ld   a, MODE_TEAMVS
	ld   [wPlayMode], a
	jp   ModeSelect_PrepVS
	
; =============== ModeSelect_Prep* ===============
; Sets of functions to set which players are controlled by the CPU, depending on the mode.

ModeSelect_PrepSingle:
	; SGB-only, wJoyActivePl is always ACTIVE_CTRL_PL1 in DMG
	ld   a, [wJoyActivePl]
	cp   ACTIVE_CTRL_PL1		; Does player 1 have control?
	jp   nz, .pl2			; If not, jump
.pl1:
	; P1: Player, P2: CPU
	ld   hl, wPlInfo_Pl1+iPlInfo_Flags0
	res  PF0B_CPU, [hl]
	ld   hl, wPlInfo_Pl2+iPlInfo_Flags0
	set  PF0B_CPU, [hl]
	call ModeSelect_MakeRoundSeq
	jp   ModeSelect_SwitchToCharSelect
.pl2:
	; P1: CPU, P2: Player
	ld   hl, wPlInfo_Pl1+iPlInfo_Flags0
	set  PF0B_CPU, [hl]
	ld   hl, wPlInfo_Pl2+iPlInfo_Flags0
	res  PF0B_CPU, [hl]
	call ModeSelect_MakeRoundSeq
	jp   ModeSelect_SwitchToCharSelect
	
ModeSelect_PrepVS:
	; P1: Player, P2: Player
	ld   hl, wPlInfo_Pl1+iPlInfo_Flags0
	res  PF0B_CPU, [hl]
	ld   hl, wPlInfo_Pl2+iPlInfo_Flags0
	res  PF0B_CPU, [hl]
	; No round sequence in 2P mode
	ld   hl, wRoundSeqId
	ld   [hl], $00
	jp   ModeSelect_SwitchToCharSelect
	
; [TCRF] Unreferenced code.
;        Sets up a CPU vs CPU battle in VS mode, which is normally restricted to 1P modes.
ModeSelect_Unused_PrepVSCPU:
	; P1: CPU, P2: CPU
	ld   hl, wPlInfo_Pl1+iPlInfo_Flags0
	set  PF0B_CPU, [hl]
	ld   hl, wPlInfo_Pl2+iPlInfo_Flags0
	set  PF0B_CPU, [hl]
	; No round sequence in 2P mode
	ld   hl, wRoundSeqId
	ld   [hl], $00
	; Fall-through
	
ModeSelect_SwitchToCharSelect:
	call ModeSelect_CheckCPUvsCPU
	
	; Initialize character select vars
	ld   a, $00
	ld   [wLastWinner], a
	ld   [$C17E], a
	ld   a, $00
	ld   [wCharSelP1CursorPos], a
	ld   a, $05
	ld   [wCharSelP2CursorPos], a
	ld   a, $FF
	ld   [wCharSelP1Char0], a
	ld   [wCharSelP1Char1], a
	ld   [wCharSelP1Char2], a
	ld   [wCharSelP2Char0], a
	ld   [wCharSelP2Char1], a
	ld   [wCharSelP2Char2], a
	
	; Force cursor to be visible while waiting
	ld   hl, wOBJInfo_Pl1+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]
	
	; Wait $3C frames
	ld   b, $3C
.wait:
	call Task_PassControl_NoDelay
	dec  b
	jp   nz, .wait
	
	ld   hl, wMisc_C028
	res  MISCB_TITLE_SECT, [hl]		; Not necessary
	
	di
	;-----------------------------------
	rst  $10				; Stop LCD
	
	; Reset screen coords
	xor  a
	ldh  [rWY], a
	ldh  [rWX], a
	ldh  [rSTAT], a
	
	; These two influence Rand and should be kept in sync across GBs
	ld   [wRand], a		
	ld   [wTimer], a
	
	; Jump to the character select screen
	ld   b, BANK(Module_CharSel) ; BANK $1E
	ld   hl, Module_CharSel
	rst  $00
	
; =============== ModeSelect_DoCtrl ===============
; Checks for player input in the mode select menu.
; OUT
; - C flag: If set, the returned value should be used
; - A: Action id (MODESELECT_ACT_*)
ModeSelect_DoCtrl:
	call Title_GetMenuInput
	bit  KEYB_START, a
	jp   nz, .select
	bit  KEYB_A, a
	jp   nz, .select
	bit  KEYB_SELECT, a
	jp   nz, .exit
	bit  KEYB_DOWN, b
	jp   nz, .moveD
	bit  KEYB_UP, b
	jp   nz, .moveU
	xor  a
	ret
.moveU:
	; Move cursor up, and wrap around
	ld   a, [wTitleSubMenuOptId]
	dec  a
	and  a, $03
	ld   [wTitleSubMenuOptId], a
	jp   .setYPos
.moveD:
	; Move cursor down, and wrap around
	ld   a, [wTitleSubMenuOptId]
	inc  a
	and  a, $03
	ld   [wTitleSubMenuOptId], a
.setYPos:
	; Set the cursor's Y position (Y = wTitleSubMenuOptId * 10) and show it, even if for a single frame
	; See also: SetCursorYPos on Options_DoCtrl
	swap a
	ld   [wOBJInfo_Pl1+iOBJInfo_Y], a
	ld   hl, wOBJInfo_Pl1+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]
	xor  a
	ret
.select:
	; A = wTitleSubMenuOptId + 1
	; MODESELECT_ACT_* follows the same order as the mode entries (which are identical to MODE_*)
	ld   a, [wTitleSubMenuOptId]
	inc  a
	scf
	ret
.exit:
	; Exit to GM_TITLE_TITLEMENU
	ld   a, MODESELECT_ACT_EXIT
	scf
	ret
	
; =============== Title_Mode_Options ===============
; Options menu.
Title_Mode_Options:
	;
	; Execute different code depending on the selected menu option.
	; Each jump target will handle controls its own way.
	;
	ld   hl, .targetPtrs			; HL = Jump Table	
	ld   d, $00
	ld   a, [wTitleSubMenuOptId]	; DE = wTitleSubMenuOptId * 2
	sla  a
	ld   e, a
	add  hl, de						; Index this table
	ld   e, [hl]					; E = Low byte target
	inc  hl
	ld   d, [hl]					; D = High byte target
	push de
	pop  hl							; Move DE to HL and jump there
	jp   hl
.targetPtrs:
	dw Options_Item_Time
	dw Options_Item_Level
	dw Options_Item_BGMTest
	dw Options_Item_SFXTest
	dw Options_Item_SGBSndTest
	dw Options_Item_Exit
	
; =============== mOptionMin ===============
; A = MIN(Value - 1, MinValue)
; IN
; - 1: Ptr to value
; - 2: Min value
; - 3: Target location on fail
mOptionMin: MACRO
	ld   a, [\1]
	cp   \2			; Value == MinValue?
	jp   z, \3		; If so, skip
	dec  a			; Value--
ENDM

; =============== mOptionMax ===============
; A = MAX(Value + 1, MaxValue)
; IN
; - 1: Ptr to value
; - 2: Min value
; - 3: Target location on fail
mOptionMax: MACRO
	ld   a, [\1]
	cp   \2			; Value == MaxValue?
	jp   z, \3		; If so, skip
	inc  a			; Value++
ENDM
	
; =============== Options_Item_Exit ===============
; EXIT option selected.
Options_Item_Exit:
	call Title_BlinkCursorR
	call Options_DoCtrl
	ret  nc
	cp   OPTIONS_ACT_EXIT		; Exiting the menu?
	jp   z, TitleSubMenu_Exit	; If so, exit
	cp   OPTIONS_ACT_A			; Pressed A on the EXIT option?
	jp   z, TitleSubMenu_Exit	; If so, exit
	ret
	
; =============== Options_Item_Time ===============	
Options_Item_Time:
	call Title_BlinkCursorR
	call Options_DoCtrl			; Check for current action
	ret  nc						; None specified? If so, return
	cp   OPTIONS_ACT_EXIT		; Act == OPTIONS_ACT_EXIT?
	jp   z, TitleSubMenu_Exit	; If so, jump
	cp   OPTIONS_ACT_L			; ...
	jp   z, .decTimer
	cp   OPTIONS_ACT_R
	jp   z, .incTimer
	ret
.decTimer:
	; Decrement the timer unless it reached the low limit.
	ld   a, [wMatchStartTime]
	cp   OPTIONS_TIMER_MIN		; Time == MinValue? 
	jp   z, .save				; If so, don't decrement
	; Special case to jump from the special Infinite value to the normal max
	cp   TIMER_INFINITE			; Time == Infinite?
	jp   nz, .doDec				; If not, jump
	ld   a, OPTIONS_TIMER_MAX					
	jp   .save
.doDec:
	sub  a, OPTIONS_TIMER_INC	; Time -= Interval
	jp   .save
.incTimer:
	; Increment the timer unless it's at the max.
	ld   a, [wMatchStartTime]	
	cp   TIMER_INFINITE			; Time == Infinite? 
	jp   z, .save				; If so, don't increment
	; Special case to jump from the normal max value to Infinite
	cp   OPTIONS_TIMER_MAX		; Time == MaxValue?
	jp   nz, .doInc				; If not, jump
	ld   a, TIMER_INFINITE
	jp   .save
.doInc:
	add  a, OPTIONS_TIMER_INC	; Time += Interval
.save:
	ld   [wMatchStartTime], a	; Save timer setting
	call Options_PrintMatchTime	; Update tilemap
	ret
	
; =============== Options_PrintMatchTime ===============
; Prints the current value of the match timer.
Options_PrintMatchTime:
	ld   a, [wMatchStartTime]
	cp   TIMER_INFINITE				; Infinite time set?
	jp   z, .infinite				; If so, jump
.num:
	ld   de, $98FE					; Otherwise print A as number
	ld   c, $00
	call NumberPrinter_Instant
	ld   hl, TextDef_Options_ClrOff	; Remove "O" from OFF
	call TextPrinter_Instant
	ret
.infinite:
	ld   hl, TextDef_Options_Off	; Print "OFF"
	call TextPrinter_Instant
	ret
	
; =============== Options_Item_Level ===============	
Options_Item_Level:
	call Title_BlinkCursorR
	call Options_DoCtrl
	ret  nc
	cp   OPTIONS_ACT_EXIT
	jp   z, TitleSubMenu_Exit
	cp   OPTIONS_ACT_L
	jp   z, .dec
	cp   OPTIONS_ACT_R
	jp   z, .inc
	ret
.dec:
	mOptionMin wDifficulty, DIFFICULTY_EASY, .save
	jp   .save
.inc:
	mOptionMax wDifficulty, DIFFICULTY_HARD, .save
.save:
	ld   [wDifficulty], a
	call Options_PrintDifficulty
	ret
	
; =============== Options_PrintDifficulty ===============
; Prints the current difficulty setting.
Options_PrintDifficulty:
	ld   a, [wDifficulty]
	cp   DIFFICULTY_EASY
	jp   z, .easy
	cp   DIFFICULTY_NORMAL
	jp   z, .normal
	cp   DIFFICULTY_HARD
	jp   z, .hard
.easy:
	ld   hl, TextDef_Options_Easy
	call TextPrinter_Instant
	ret
.normal:
	ld   hl, TextDef_Options_Normal
	call TextPrinter_Instant
	ret
.hard:
	ld   hl, TextDef_Options_Hard
	call TextPrinter_Instant
	ret
	
; =============== Options_Item_BGMTest ===============	
Options_Item_BGMTest:;I
	call Title_BlinkCursorR
	call Options_DoCtrl
	ret  nc
	cp   OPTIONS_ACT_EXIT
	jp   z, TitleSubMenu_Exit
	cp   OPTIONS_ACT_L
	jp   z, .dec
	cp   OPTIONS_ACT_R
	jp   z, .inc
	cp   OPTIONS_ACT_A
	jp   z, .play
	cp   OPTIONS_ACT_B
	jp   z, .stop
	ret ; We don't get here
.play:
	; Index the real sound ID off the map table
	ld   a, [wOptionsBGMId]			; A = VisualBGMId
	ld   hl, Options_BGMIdMapTbl	; HL = MapTable
	ld   d, $00
	ld   e, a
	add  hl, de						
	ld   a, [hl]					; SoundId = HL[A]
	; Play that
	call HomeCall_Sound_ReqPlayId
	ret
.stop:
	xor  a
	call HomeCall_Sound_ReqPlayId
	ret
.dec:
	mOptionMin wOptionsBGMId, $00, .save
	jp   .save
.inc:
	mOptionMax wOptionsBGMId, Options_BGMIdMapTbl.end-Options_BGMIdMapTbl-1, .save
.save:
	ld   [wOptionsBGMId], a
	call Options_PrintBGMId
	ret	
; =============== Options_BGMIdMapTbl ===============
; Maps the BGM Ids to the sound IDs used by the sound driver.
Options_BGMIdMapTbl: 
	db BGM_IN1996               ; $01
	db BGM_ESAKA                ; $02
	db BGM_BIGSHOT              ; $03
	db BGM_ARASHI               ; $04
	db BGM_GEESE                ; $05
	db BGM_FAIRY                ; $06
	db BGM_TRASHHEAD            ; $07
	db BGM_MRKARATE             ; $08
	db BGM_ROULETTE             ; $09
	db BGM_STAGECLEAR           ; $0A
	db BGM_WIND                 ; $0B
	db BGM_TOTHESKY             ; $0C
	db BGM_PROTECTOR            ; $0D
	db BGM_MRKARATECUTSCENE     ; $0E
	db BGM_RISINGRED            ; $0F
.end:
                                
; =============== Options_PrintBGMId ===============
; Prints the current BGM number.
Options_PrintBGMId:
	ld   a, [wOptionsBGMId]		; A = wOptionsBGMId+1
	inc  a
	ld   de, $997E				; DE = Location
	ld   c, $00					; C = Tile ID base
	call NumberPrinter_Instant
	ret
	
Options_Item_SFXTest:;I
	call Title_BlinkCursorR
	call Options_DoCtrl
	ret  nc
	cp   OPTIONS_ACT_EXIT
	jp   z, TitleSubMenu_Exit
	cp   OPTIONS_ACT_L
	jp   z, .dec
	cp   OPTIONS_ACT_R
	jp   z, .inc
	cp   OPTIONS_ACT_A
	jp   z, .play
	cp   OPTIONS_ACT_B
	jp   z, .stop
	ret ; We don't get here
.play:
	; Index the real sound ID off the map table
	ld   a, [wOptionsSFXId]			; A = VisualSFXId
	ld   hl, Options_SFXIdMapTbl	; HL = MapTable
	ld   d, $00
	ld   e, a
	add  hl, de						
	ld   a, [hl]					; SoundId = HL[A]
	; Play that
	call HomeCall_Sound_ReqPlayId
	ret
.stop:
	xor  a
	call HomeCall_Sound_ReqPlayId
	ret
.dec:
	mOptionMin wOptionsSFXId, $00, .save
	jp   .save
.inc:
	mOptionMax wOptionsSFXId, Options_SFXIdMapTbl.end-Options_SFXIdMapTbl-1, .save
.save:
	ld   [wOptionsSFXId], a
	call Options_PrintSFXId
	ret
; =============== Options_SFXIdMapTbl ===============
; Maps the SFX Ids to the sound IDs used by the sound driver.
Options_SFXIdMapTbl:
	db SFX_CHARCURSORMOVE ; $01
	db SFX_CHARSELECTED   ; $02
	db SFX_METERCHARGE    ; $03
	db SFX_SUPERMOVE      ; $04
	db SFX_LIGHT          ; $05
	db SFX_HEAVY          ; $06
	db SND_ID_14          ; $07
	db SFX_TAUNT          ; $08
	db SFX_HIT            ; $09
	db SND_ID_17          ; $0A
	db SND_ID_1A          ; $0B
	db SFX_DROP           ; $0C
	db SFX_SUPERJUMP      ; $0D
	db SFX_STEP           ; $0E
	db SND_ID_26          ; $0F
	db SFX_GRABSTART      ; $10
	db SND_ID_28          ; $11
	db SND_ID_29          ; $12
	db SND_ID_2A          ; $13
	db SND_ID_2B          ; $14
	db SND_ID_2C          ; $15
	db SND_ID_2D          ; $16
	db SND_ID_2E          ; $17
	db SND_ID_2F          ; $18
	db SND_ID_30          ; $19
	db SFX_GAMEOVER       ; $1A
.end:
 
; =============== Options_PrintSFXId ===============
; Prints the current SFX number.
Options_PrintSFXId:
	ld   a, [wOptionsSFXId]		; A = wOptionsSFXId+1
	inc  a
	ld   de, $99BE
	ld   c, $00
	call NumberPrinter_Instant
	ret
	
; =============== Options_Item_SGBSndTest ===============
Options_Item_SGBSndTest:
	;
	; There are two cursor modes here because selecting this option
	; activates a submenu.
	;
	ld   hl, .modePtrs			; HL = Jump table
	ld   d, $00
	ld   a, [wOptionsMenuMode]	; DE = wOptionsMenuMode
	ld   e, a
	add  hl, de						
	ld   e, [hl]					
	inc  hl
	ld   d, [hl]
	push de
	pop  hl
	jp   hl
  
.modePtrs:
 	dw SGBSndTest_Hover
	dw SGBSndTest_SubMenu
	
; =============== SGBSndTest_Hover =============== 
; When hovering over the main SGB Test option.
SGBSndTest_Hover:
	call Title_BlinkCursorR
	call Options_DoCtrl
	ret  nc
	cp   a, OPTIONS_ACT_EXIT
	jp   z, TitleSubMenu_Exit
	cp   a, OPTIONS_ACT_R
	jp   z, .enterSubMenu
	ret 
	
.enterSubMenu:
	; Start on leftmost option
	ld   a, $00
	ld   [wOptionsSGBSndOptId], a
	; Enter option
	ld   a, OPTION_MENU_SGBTEST
	ld   [wOptionsMenuMode], a
	; Show both cursors
	ld   hl, wOBJInfo_CursorR+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]
	ld   hl, wOBJInfo_CursorU+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]
	; Set initial CursorU position for leftmost option
	ld   hl, wOBJInfo_CursorU+iOBJInfo_X
	ld   [hl], $3C
	ld   hl, wOBJInfo_CursorU+iOBJInfo_Y
	ld   [hl], $60
	ret 
	
; =============== SGBSndTest_SubMenu =============== 
; Selecting a digit.
SGBSndTest_SubMenu:
	call Title_BlinkCursorU
	call Options_SGBSndTest_DoCtrl
	ret  nc
	cp   a, OPTIONS_SACT_EXIT
	jp   z, TitleSubMenu_Exit
	cp   a, OPTIONS_SACT_UP
	jp   z, SGBSndTest_Act_DecNum
	cp   a, OPTIONS_SACT_DOWN
	jp   z, SGBSndTest_Act_IncNum
	cp   a, OPTIONS_SACT_A
	jp   z, SGBSndTest_Act_PlaySound
	cp   a, OPTIONS_SACT_B
	jp   z, SGBSndTest_Act_StopSound
	cp   a, OPTIONS_SACT_SUBEXIT
	jp   z, SGBSndTest_Act_Exit
	ret 
	
; =============== SGBSndTest_SubMenu =============== 
; Returns to the main options selection.
SGBSndTest_Act_Exit:
	ld   a, $00						; Reset CursorU pos
	ld   [wOptionsSGBSndOptId], a
	ld   a, OPTION_MENU_NORMAL		; Back to options
	ld   [wOptionsMenuMode], a
	; Hide up cursor
	ld   hl, wOBJInfo_CursorU+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	ret  
	
; =============== SGBSndTest_Act_DecNum =============== 
; Decreases the selected option digit.
SGBSndTest_Act_DecNum:                  
	; Get the address where the number is stored
	ld   a, [wOptionsSGBSndOptId]		; D = OptionId
	ld   d, a
	call SGBSndTest_GetOptPtr			; HL = Option value
	
	ld   a, [hl]						; A = Current digit
	bit  0, d							; Editing the bank number? (OptionId == 1 || OptionId == 3)
	jp   nz, .dec						; If so, always decrease it (allow wraparound)
.isSet:
	cp   a, $00							; Digit == $00?
	jp   z, SGBSndTest_Act_IncNum.end	; If so, skip
.dec:
	dec  a								; Digit--
	ld   [hl], a						; Save it back
	jp   SGBSndTest_Act_IncNum.end
	
; =============== SGBSndTest_Act_DecNum =============== 
; Increases the selected option digit.
SGBSndTest_Act_IncNum:
	; Get the address where the number is stored
	ld   a, [wOptionsSGBSndOptId]	; D = OptionId
	ld   d, a
	call SGBSndTest_GetOptPtr		; HL = Option value
	
	; There are different upper limits for each number.
	; The bit checks work due to how the Option IDs are ordered.
	ld   a, [hl]			; A = Current digit
	bit  0, d				; Editing the bank number? (OptionId == 1 || OptionId == 3)
	jp   nz, .inc			; If so, always increase (allow wraparound)
	bit  1, d				; Is this for Set B? (OptionId == 2 || OptionId == 3)
	jp   nz, .setB			; If so, jump
.setA:
	cp   a, $30				; Set A max sound ID
	jp   z, .end			; A == $30? If so, don't increase it
	jp   .inc
.setB:
	cp   a, $19				; Set B max sound ID
	jp   z, .end			; A == $19? If so, don't increase it
.inc:
	inc  a					; Digit++
	ld   [hl], a			; Save it back
.end:
	call Options_PrintSGBSndTestVals
	ret  
	
; =============== SGBSndTest_Act_PlaySound =============== 
SGBSndTest_Act_PlaySound:
	ld   a, [wOptionsSGBSndOptId]
	bit  1, a							; Set B selected?
	jp   nz, .setB						; If so, jump
.setA:
	; Set the options in the SGB packet.
	ld   hl, wOptionsSGBPacketSndIdA	; HL = Ptr to SGB Sound Packet byte1
	; Set A Sound ID
	ld   a, [wOptionsSGBSndIdA]			; wOptionsSGBPacketSndIdA = wOptionsSGBSndIdA
	ldi  [hl], a						
	; Nothing in Set B
	ld   a, $00							; wOptionsSGBPacketSndIdB = 0
	ldi  [hl], a				
	; Low nybble -> Bank number for Set A
	ld   a, [wOptionsSGBSndBankA]		; wOptionsSGBPacketSndBank = wOptionsSGBSndBankA & $0F
	and  a, $0F							; filter valid values
	ldi  [hl], a
	jp   .sendPkg
.setB:
	ld   hl, wOptionsSGBPacketSndIdA	; HL = Ptr to SGB Sound Packet byte1
	; Nothing in Set A
	ld   a, $80							; wOptionsSGBPacketSndIdA = $80
	ldi  [hl], a
	; Set B Sound ID
	ld   a, [wOptionsSGBSndIdB]			; wOptionsSGBPacketSndIdB = wOptionsSGBSndIdB
	ldi  [hl], a
	; High nybble -> Bank number for Set B
	ld   a, [wOptionsSGBSndBankB]		; wOptionsSGBPacketSndBank = (wOptionsSGBSndBankB & $0F) << 4
	and  a, $0F							; filter valid values
	swap a
	ldi  [hl], a
.sendPkg:
	call Task_PassControl_NoDelay
	ld   hl, wOptionsSGBPacketSnd
	call SGB_SendPackets
	ret  
	
; =============== SGBSndTest_Act_StopSound =============== 
SGBSndTest_Act_StopSound:
	call Task_PassControl_NoDelay
	ld   hl, SGBPacket_Options_StopSnd
	call SGB_SendPackets
	ei   
	ret  
	
; =============== SGBSndTest_GetOptPtr ===============
; HL = wOptionsSGBBase[wOptionsSGBSndOptId]
; OUT
; - HL: Ptr to value of the currently selected option
SGBSndTest_GetOptPtr:
	; The current values for the four SGB options start at wOptionsSGBBase.
	; They are ordered by OPTION_SITEM_*, so getting their address is like indexing a table.
	ld   hl, wOptionsSGBBase		; HL = Starting address
	ld   a, [wOptionsSGBSndOptId]	; BC = SGB Option Id
	ld   b, $00
	ld   c, a
	add  hl, bc						; Index it
	ret
	
; =============== Options_PrintSGBSndTestVals ===============
; Prints the digits displayed in the SGB sound test.
Options_PrintSGBSndTestVals:

	; SGB Mode only
	ld   a, [wMisc_C025]
	bit  MISCB_IS_SGB, a
	jp   z, .ret
	
	; Don't print if the SGB sound test isn't enabled
	ld   a, [wDipSwitch]
	bit  DIPB_SGB_SOUND_TEST, a
	jp   z, .ret
	
	; Print out all of the digits
	ld   a, [wOptionsSGBSndIdA]
	ld   de, $9A56
	ld   c, $00
	call NumberPrinter_Instant
	
	ld   a, [wOptionsSGBSndBankA]
	ld   de, $9A58
	ld   c, $00
	call NumberPrinter_Instant
	
	ld   a, [wOptionsSGBSndIdB]
	ld   de, $9A5C
	ld   c, $00
	call NumberPrinter_Instant
	
	ld   a, [wOptionsSGBSndBankB]
	ld   de, $9A5E
	ld   c, $00
	call NumberPrinter_Instant
	
	; Blank out high digit of banks A & B
	ld   hl, TextDef_Options_ClrSGBSndA
	call TextPrinter_Instant
	ld   hl, TextDef_Options_ClrSGBSndB
	call TextPrinter_Instant
.ret:
	ret 
	
; =============== Options_PrintDipSwitch ===============
; Prints the current dip switch value.
Options_PrintDipSwitch:
	; Don't reveal the feature if no dipswitches are enabled.
	ld   a, [wDipSwitch]
	or   a					; wDipSwitch == 0?
	jp   z, .ret			; If so, return
.ok:
	ld   de, $9ABE
	ld   c, $00
	call NumberPrinter_Instant
.ret:
	ret
	
; =============== Options_DoCtrl ===============
; Checks for player input in the options menu.
; OUT
; - C flag: If set, the returned value should be used
; - A: Action id (OPTIONS_ACT_*), handled by the option-specific code
Options_DoCtrl:
	call Title_GetMenuInput
	bit  KEYB_START, a
	jp   nz, Options_DoCtrl_Exit
	bit  KEYB_SELECT, a
	jp   nz, Options_DoCtrl_Exit
	bit  KEYB_B, a
	jp   nz, Options_DoCtrl_PressB
	bit  KEYB_DOWN, b
	jp   nz, Options_DoCtrl_MoveD
	bit  KEYB_UP, b
	jp   nz, Options_DoCtrl_MoveU
	bit  KEYB_LEFT, b
	jp   nz, Options_DoCtrl_MoveL
	bit  KEYB_RIGHT, b
	jp   nz, Options_DoCtrl_MoveR
	bit  KEYB_A, b
	jp   nz, Options_DoCtrl_PressA
	xor  a
	ret
	
; =============== Options_DoCtrl_Exit ===============
Options_DoCtrl_Exit:
	ld   a, OPTIONS_ACT_EXIT	; Action
	scf							; Enable action
	ret
; =============== Options_DoCtrl_MoveU ===============
Options_DoCtrl_MoveU:
	;
	; Wrap around from OPTION_ITEM_TIME to OPTION_ITEM_EXIT
	;
	ld   a, [wTitleSubMenuOptId]
	or   a							; Are we over the highest option? (OPTION_ITEM_TIME)
	jp   nz, .chkOpen				; If not, jump
	ld   a, OPTION_ITEM_EXIT		; Otherwise, wrap around
	jp   .end
.chkOpen:
	;
	; Skip the SGB sound test option if it's disabled
	;
	ld   hl, wMisc_C025
	bit  MISCB_IS_SGB, [hl]			; Are we in SGB mode?
	jp   z, .noSGBTest				; If not, jump
	ld   hl, wDipSwitch
	bit  DIPB_SGB_SOUND_TEST, [hl]	; Is the SGB sound test enabled?
	jp   nz, .moveUp				; If so, we can always move up
.noSGBTest:
	; If we got here there's no SGB sound test, so skip it
	cp   OPTION_ITEM_EXIT			; Are we over the EXIT option?
	jp   nz, .moveUp				; If not, move up
	ld   a, OPTION_ITEM_SFXTEST		; Otherwise, skip directly to SFX Test
	jp   .end
.moveUp:
	dec  a							; Move selected option up		
.end:
	ld   [wTitleSubMenuOptId], a
	jp   Options_DoCtrl_SetCursorYPos
	
; =============== Options_DoCtrl_MoveD ===============
Options_DoCtrl_MoveD:
	;
	; Wrap around from OPTION_ITEM_EXIT to OPTION_ITEM_TIME
	;
	ld   a, [wTitleSubMenuOptId]
	cp   OPTION_ITEM_EXIT			; Are we over the lowest option?
	jp   nz, .chkOpen				; If not, jump
	ld   a, OPTION_ITEM_TIME		; Otherwise, wrap around
	jp   .end
.chkOpen:
	ld   hl, wMisc_C025
	bit  MISCB_IS_SGB, [hl]			; Are we in SGB mode?
	jp   z, .noSGBTest				; If not, jump
	ld   hl, wDipSwitch
	bit  DIPB_SGB_SOUND_TEST, [hl]	; Is the SGB sound test enabled?
	jp   nz, .moveDown				; If so, we can always move down
.noSGBTest:
	; If we got here there's no SGB sound test, so skip it
	cp   OPTION_ITEM_SFXTEST		; Are we over the SFX Test option?
	jp   nz, .moveDown				; If not, move down
	ld   a, OPTION_ITEM_EXIT		; Otherwise, skip directly to EXIT
	jp   Options_DoCtrl_MoveU.end	; (Does the same thing as the line below)
	jp   .end						; [TCRF] Unreachable duplicate jump
.moveDown:
	inc  a							; Move selected option down
.end:
	ld   [wTitleSubMenuOptId], a
	; Fall-through
; =============== Options_DoCtrl_SetCursorYPos ===============
; Common code for setting the new cursor Y position.
; The X position is never changed in menus.
; IN
; - A: wTitleSubMenuOptId
Options_DoCtrl_SetCursorYPos:
	cp   OPTION_ITEM_EXIT			; Are we now over the EXIT option?
	jp   nz, .otherY				; If not, jump
.exitY:
	ld   a, $68						; Otherwise, Y pos = $68
	jp   .setY
.otherY:
	; ID trickery.
	; The menu options (outside of EXIT) are positioned in a way so that:
	; CursorY = wTitleSubMenuOptId * 4
	swap a
.setY:
	ld   [wOBJInfo_CursorR+iOBJInfo_Y], a		; Set the Y cursor
	ld   hl, wOBJInfo_CursorR+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]						; Force cursor visibility, at least for 1 frame
	xor  a
	ret
; =============== Options_DoCtrl_MoveL ===============
Options_DoCtrl_MoveL:
	ld   a, OPTIONS_ACT_L
	scf
	ret
; =============== Options_DoCtrl_MoveR ===============
Options_DoCtrl_MoveR:
	ld   a, OPTIONS_ACT_R
	scf
	ret
; =============== Options_DoCtrl_PressA ===============
Options_DoCtrl_PressA:
	ld   a, OPTIONS_ACT_A
	scf
	ret
; =============== Options_DoCtrl_PressB ===============
Options_DoCtrl_PressB:
	ld   a, OPTIONS_ACT_B
	scf
	ret
	
	
; =============== Options_SGBSndTest_DoCtrl ===============	
; Special version of Options_DoCtrl used for the SGB Sound Test.
; This uses an up cursor moving horizontally, so movement is handled differently.
; OUT
; - C flag: If set, the returned value should be used
; - A: Action id (OPTIONS_SACT_*), handled by the option-specific code
Options_SGBSndTest_DoCtrl:
	call Title_GetMenuInput
	bit  KEYB_START, a
	jp   nz, .exit
	bit  KEYB_SELECT, a
	jp   nz, .exit
	bit  KEYB_LEFT, a
	jp   nz, .moveL
	bit  KEYB_RIGHT, a
	jp   nz, .moveR
	bit  KEYB_B, a
	jp   nz, .b
	bit  KEYB_DOWN, b
	jp   nz, .down
	bit  KEYB_UP, b
	jp   nz, .up
	bit  KEYB_A, b
	jp   nz, .a
	xor  a
	ret
.exit:
	ld   a, OPTIONS_SACT_EXIT
	scf  
	ret  
.up:
	ld   a, OPTIONS_SACT_UP
	scf  
	ret  
.down:
	ld   a, OPTIONS_SACT_DOWN
	scf  
	ret  
.a:
	ld   a, OPTIONS_SACT_A
	scf  
	ret  
.b:
	ld   a, OPTIONS_SACT_B
	scf  
	ret  
;--
.moveL:
	; If we're moving left from the leftmost option, signal out the exit from the submenu
	ld   a, [wOptionsSGBSndOptId]
	cp   a, OPTION_SITEM_ID_A		; OptionId == 0?
	jp   z, .leftMin				; If so, jump
	; Otherwise decrement the option
	dec  a				
	and  a, $03						; And force it in range ($00-$03)
	jp   .setCursorXPos
.leftMin:
	ld   a, OPTIONS_SACT_SUBEXIT
	scf  
	ret 
;--
.moveR:
	; If we're moving right from the leftmost option, ignore it
	ld   a, [wOptionsSGBSndOptId]
	cp   a, OPTION_SITEM_BANK_B		; OptionId == $03?
	jp   z, .setCursorXPos			; If so, jump
	; Otherwise increment the option
	inc  a
	and  a, $03						; And force it in range ($00-$03)
	
.setCursorXPos:
	;
	; Determine the up cursor's X position.
	; Unlike Options_DoCtrl, there's no trickery here, it's just a series of id checks.
	;
	ld   [wOptionsSGBSndOptId], a
	cp   a, OPTION_SITEM_BANK_A		; OptionId == $01?
	jp   z, .x1						; If so, jump
	cp   a, OPTION_SITEM_ID_B		; ...
	jp   z, .x2
	cp   a, OPTION_SITEM_BANK_B
	jp   z, .x3
	; Otherwise, OptionId == $00
.x0:
	ld   a, $3C
	jp   .saveX
.x1:
	ld   a, $50
	jp   .saveX
.x2:
	ld   a, $6C
	jp   .saveX
.x3:
	ld   a, $80
.saveX:
	; Show up cursor and set its position
	ld   [wOBJInfo_CursorU+iOBJInfo_X], a
	ld   hl, wOBJInfo_CursorU+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]
	xor  a
	ret
	
; =============== TitleSubMenu_Exit ===============
; Exits from the mode select or options menu back to the title menu.
TitleSubMenu_Exit:
	
	; Disable serial (Mode Select)
	xor  a
	ldh  [rSB], a
	
	; Stop any playing SGB sound (Options)
	ld   hl, SGBPacket_Options_StopSnd
	call SGB_SendPackets
	
	; Reset DMG pal
	ld   a, $FF
	ldh  [rBGP], a
	ldh  [rOBP0], a
	ldh  [rOBP1], a
	
	; Next mode
	ld   a, GM_TITLE_TITLEMENU
	ld   [wTitleMode], a
	
	; Load GFX
	ld   b, BANK(Title_LoadVRAM_Mini) ; BANK $1C
	ld   hl, Title_LoadVRAM_Mini
	rst  $08
	
	; Enable title screen parallax mode
	ld   hl, wMisc_C028
	set  MISCB_TITLE_SECT, [hl]
	
	; Restore cursor position & visibility
	ld   a, [wTitleMenuCursorXBak]
	ld   [wOBJInfo_CursorR+iOBJInfo_X], a
	ld   a, [wTitleMenuCursorYBak]
	ld   [wOBJInfo_CursorR+iOBJInfo_Y], a
	ld   hl, wOBJInfo_CursorR+iOBJInfo_OBJLstPtrTblOffset
	ld   [hl], TITLE_OBJ_CURSOR_R*OBJLSTPTR_ENTRYSIZE
	ld   hl, wOBJInfo_Pl1+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]
	
	; Hide vertical cursor
	ld   hl, wOBJInfo_CursorU+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	
	; Show menu text and SNK copyright
	ld   hl, wOBJInfo_MenuText+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]
	ld   hl, wOBJInfo_SnkText+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]
	
	; Reset scrolling to make clouds appear already at the final Y pos
	; without having to move them up again
	ld   a, $00
	ld   [wOBJScrollY], a
	ld   a, $90 		; Matches with Y target in Title_UpdateParallaxCoords
	ldh  [hScrollY], a
	
	; Enable WINDOW
	ld   a, LCDC_PRIORITY|LCDC_OBJENABLE|LCDC_OBJSIZE|LCDC_WENABLE|LCDC_WTILEMAP|LCDC_ENABLE
	rst  $18				; Resume LCD
	;-----------------------------------
	
	; Enable LYC interrupt
	ldh  a, [rSTAT]
	or   a, STAT_LYC
	ldh  [rSTAT], a
	ld   a, $66			; Same as title init code
	ldh  [rLYC], a
	ldh  a, [rIE]
	or   a, I_STAT|I_VBLANK
	ldh  [rIE], a
	
	; Stop DMG sound
	ld   a, $00
	call HomeCall_Sound_ReqPlayExId_Stub
	
	call Task_PassControl_NoDelay
	
	; Set DMG title pal
	ld   a, $3F
	ldh  [rOBP0], a
	ld   a, $00
	ldh  [rOBP1], a
	ld   a, $1B
	ldh  [rBGP], a
	ret

; =============== TitleScreen_IsStartPressed ===============
; OUT
; - C flag: If set, START was pressed on either controller
TitleScreen_IsStartPressed:
	; Serial is disabled, so hJoyNewKeys2 will only come from the SGB side.
	
	; Whoever presses START on the PUSH START screen takes control of the main menu,
	; while the other player won't be able to do anything.
	
	ldh  a, [hJoyNewKeys]
	bit  KEYB_START, a		; Pressing START on P1 side?
	jp   nz, .pressed1		; If so, jump
	ldh  a, [hJoyNewKeys2]
	bit  KEYB_START, a		; Pressing START on P2 side?	
	jp   nz, .pressed2		; If so, jump
.notPressed:
	xor  a					; C = 0, not pressed
	ret
.pressed1:
	ld   a, ACTIVE_CTRL_PL1	; Player 1 pressed it
	ld   [wJoyActivePl], a
	scf						; C = 1, pressed
	ret
.pressed2:
	ld   a, ACTIVE_CTRL_PL2	; Player 2 pressed it
	ld   [wJoyActivePl], a
	scf						; C = 1, pressed
	ret
	
; =============== ModeSelect_CheckCPUvsCPU ===============
; [POI] Handles the secret where holding B when selecting a mode activates a CPU vs CPU battle.
ModeSelect_CheckCPUvsCPU:

	; CPU vs CPU disallowed in VS modes.
	ld   a, [wMisc_C025]
	bit  MISCB_SERIAL_MODE, a		; Setting up a VS battle?
	ret  nz							; If so, return
	
	; Check both controllers
.chkPl1:
	ldh  a, [hJoyKeys]
	bit  KEYB_B, a					; Holding B on controller 1?
	jp   z, .chkPl2					; If not, jump
	ld   hl, wPlInfo_Pl1+iPlInfo_Flags0
	set  PF0B_CPU, [hl]				; Otherwise, set P1 as CPU
.chkPl2:
	ldh  a, [hJoyKeys2]
	bit  KEYB_B, a					; Holding B on controller 2?
	jp   z, .ret					; If not, jump
	ld   hl, wPlInfo_Pl2+iPlInfo_Flags0
	set  PF0B_CPU, [hl]				; Otherwise, set P2 as CPU
.ret:
	ret
	
; =============== Title_GetMenuInput ===============
; Gets the player input for the menu screens.
; This merges the key info from the delayed held input fields set in JoyKeys_DoCursorDelayTimer.
; OUT
; - B: Pressed KEY_*
Title_GetMenuInput:
	
	;
	; Pick the controller from the active side
	;
	ld   a, [wJoyActivePl]
	cp   ACTIVE_CTRL_PL1			; Is pad 1 active?
	jp   nz, .usePl2			; If not, jump
.usePl1:
	ld   hl, hJoyKeys			; HL = Controller 1 input
	jp   .getKeys
.usePl2:
	ld   hl, hJoyKeys2			; HL = Controller 2 input

.getKeys:

	;
	; If we're holding any key, force blinking sprites to be visible (in practice, the cursor)
	;
	ld   a, [hl]				; A = Held keys
	or   a						; Holding anything?
	jp   z, .calcKeys			; If not, skip
	xor  a						; Otherwise, reset the blink timer
	ld   [wTitleBlinkTimer], a
	
.calcKeys:
	inc  hl						; Seek to hJoyNewKeys
	ld   a, [hl]				; A = Newly pressed keys
	push af
		inc  hl
		inc  hl					; Seek to hJoyKeysDelayTbl
		
		;
		; Merge back the bits in the 8 iKeyMenuHeld fields into a into a KEY_* bitmask.
		;
		
		; For each DelayTbl entry mark the MSB if needed and rotate left.
		
		ld   b, $00				; B = Output KEY_* mask
		ld   c, $08				; C = Bits in byte
	.loop:
		ldi  a, [hl]			; A = iKeyMenuHeld
		inc  hl					; Skip to next entry
		; Only use key entries with value $01, which means that either:
		; - The key was just pressed
		; - The delay countdown reached 0, which set the key entry to $01
		cp   $01				; iKeyMenuHeld == $01?
		jp   nz, .next			; If not, skip
		set  7, b				; Set the MSB
	.next:
		rlc  b					; Next bit (<<R 1)
		dec  c					; BitsLeft--
		jp   nz, .loop			; Are we done? If not, loop
	pop  af
	ret
	
; =============== TitleScreen_BlinkPushStartText ===============
; Blinks the PUSH START text every $10 frames.
TitleScreen_BlinkPushStartText:
	ld   a, [wTitleBlinkTimer]		; Timer++
	inc  a
	ld   [wTitleBlinkTimer], a
	bit  4, a						; Timer & $10 == 0?
	jp   z, .show					; If so, show it
.hide:								; Otherwise, hide it
	ld   hl, wOBJInfo_MenuText+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	ret
.show:
	ld   hl, wOBJInfo_MenuText+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]
	ret
; =============== Title_BlinkCursorR ===============
; Blinks the horizontal cursor every $08 frames.
Title_BlinkCursorR:
	ld   a, [wTitleBlinkTimer]		; Timer++
	inc  a
	ld   [wTitleBlinkTimer], a
	bit  3, a						; Timer & $08 == 0?
	jp   z, .show					; If so, show it
.hide:								; Otherwise, hide it
	ld   hl, wOBJInfo_CursorR+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	ret
.show:
	ld   hl, wOBJInfo_CursorR+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]
	ret
; =============== Title_BlinkCursorU ===============
; Blinks the vertical cursor every $08 frames.
Title_BlinkCursorU:
	ld   a, [wTitleBlinkTimer]		; Timer++
	inc  a
	ld   [wTitleBlinkTimer], a
	bit  3, a						; Timer & $08 == 0?
	jp   z, .show					; If so, show it
.hide:								; Otherwise, hide it
	ld   hl, wOBJInfo_CursorU+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	ret
.show:
	ld   hl, wOBJInfo_CursorU+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]
	ret
	
; =============== Title_UpdateParallaxCoords ===============
; Updates the positions for the various cloud strips for the parallax effect.
Title_UpdateParallaxCoords:

	;
	; Move clouds up by scrolling the BG down $00.40px/frame until Y $90 is reached.
	;
	ldh  a, [hScrollY]
	cp   $90				; hScrollY == $90?
	jp   z, .scrollX		; If so, skip
	ld   hl, hScrollY		
	ld   bc, $0040			; hScrollY += $00.40
	call .addToPos	
	
.scrollX:

	;
	; Scroll the clouds horizontally.
	; The higher the section number, the faster it will scroll.
	;
	ld   hl, hScrollX
	ld   bc, $0040
	call .addToPos
	ld   hl, hTitleParallax1X
	ld   bc, $0060
	call .addToPos
	ld   hl, hTitleParallax2X
	ld   bc, $0080
	call .addToPos
	ld   hl, hTitleParallax3X
	ld   bc, $00A0
	call .addToPos
	ld   hl, hTitleParallax4X
	ld   bc, $00C0
	call .addToPos
	ld   hl, hTitleParallax5X
	ld   bc, $00E0
	call .addToPos
	ret

; IN
; - HL: Ptr to pixel position
; - BC: Amount to add
.addToPos:
	; HL += BC + *wTitleParallaxBaseSpeed
	push hl
		; HL += BC
		call Title_AddWithSubpixels
		
		; HL += wTitleParallaxBaseSpeed
		ld   hl, wTitleParallaxBaseSpeed
		ld   b, [hl]		; Pixel count
		inc  hl
		ld   c, [hl]		; Subpixel count
	pop  hl
	call Title_AddWithSubpixels
	ret
	
; =============== Title_AddWithSubpixels ===============
; Adds the specified number of pixels to a coordinate.
; This requires the coordinate pointed by HL to be 2 bytes large:
; - 0 -> Pixel value
; - 2 -> Subpixel value
; IN
; - HL: Ptr to pixel position
; - B: Pixels to add
; - C: Subpixels to add
Title_AddWithSubpixels:
	push hl ; Save coord ptr
		; HL = Coordinate
		ld   d, [hl]	; D = Pixels
		inc  hl
		ld   e, [hl]	; E = Subpixels
		push de			;
		pop  hl			; Move to HL
		
		; DE = HL + BC
		add  hl, bc		
		push hl
		pop  de
	pop  hl ; Restore coord ptr
	
	; Write back updated coord
	ld  [hl], d		; Write pixels
	inc  hl
	ld   [hl], e	; Write subpixels
	ret
	
; =============== ModeSelect_MakeRoundSeq ===============
; Generates the sequence of opponents to fight in 1P modes.
ModeSelect_MakeRoundSeq:
	; Reset starting round
	ld   hl, wRoundSeqId
	ld   [hl], $00
	
	;
	; Fill the sequence with $FF values.
	;
	ld   b, $12				; B = Total number of opponents
	ld   hl, wRoundSeqTbl	; HL = Ptr to start of table
	ld   a, $FF				; A = Overwrite with
.fillLoop:
	ldi  [hl], a			
	dec  b
	jr   nz, .fillLoop
	
	;
	; Randomize the first 14 opponents (all of the normal ones).
	; This *does* mean you will always fight both normal and boss Chizuru.
	;
	
	; This is done by going through character *select* portrait IDs from highest allowed to lowest,
	; and placing that character in a randomly generated slot in wRoundSeqTbl.
	ld   b, $0E				; B = Current CHARSEL_ID_* / Remaining chars
.getRand:
	call RandLY				; A = Random opponent slot
	and  a, $0F				; Filter valid IDs only
	cp   $0F				; Did we get Kagura's slot? (15th character in the sequence)
	jr   z, .getRand		; If so, reroll again
	
	; HL = Ptr to generated slot
	ld   d, $00				; DE = Current index
	ld   e, a
	ld   hl, wRoundSeqTbl	; HL = wRoundSeqTbl
	add  hl, de				; Index it
	
	; Avoid overwriting already filled slots, which don't have the $FF placeholder anymore
	ld   a, [hl]			; A = SlotVal
	cp   $FF				; SlotVal != $FF?
	jr   nz, .getRand		; If so, reroll
	
	; Replace Mr Karate ($0E) with Leona ($11)
	; The CHARSEL_ID_* values are in the same order as the character select screen from left to right, top to bottom.
	; Leona is the only character after the hidden ones, as the last one in the lower right corner.
	ld   a, b					; B = CHARSEL_ID_* value
	cp   CHARSEL_ID_MRKARATE0	; B == $0E?
	jr   nz, .setCharId			; If so, skip
	ld   a, CHARSEL_ID_LEONA
.setCharId:
	ld   [hl], a			; Write value
	dec  b					; CharsLeft--
	ld   a, b				
	cp   $FF				; CharsLeft < 0?
	jp   nz, .getRand		; If not, generate the next one
	
	;
	; Add the 2 bosses and 2 secrets at the end.
	; These are raw character IDs as they don't go through the char select screen.
	;
	ld   hl, wRoundSeqTbl+$0F
	ld   [hl], CHAR_ID_KAGURA/2
	inc  hl
	ld   [hl], CHAR_ID_GOENITZ/2
	inc  hl
	ld   [hl], $00 ; Placeholder for bonus fight, team-specific.
	inc  hl
	ld   [hl], CHAR_ID_MRKARATE/2
	ret
	
OBJInfoInit_Title:
	db OST_VISIBLE
	db $00 ; iOBJInfo_OBJLstFlags
	db $00 ; iOBJInfo_OBJLstFlagsView
	db $28 ; iOBJInfo_X
	db $00 ; iOBJInfo_XSub
	db $40 ; iOBJInfo_Y
	db $00 ; iOBJInfo_YSub
	db $00 ; iOBJInfo_SpeedX
	db $00 ; iOBJInfo_SpeedXSub
	db $00 ; iOBJInfo_SpeedY
	db $00 ; iOBJInfo_SpeedYSub
	db $00 ; iOBJInfo_RelX (auto)
	db $00 ; iOBJInfo_RelY (auto)
	db $00 ; iOBJInfo_TileIDBase
	db LOW($8000) ; iOBJInfo_VRAMPtr_Low
	db HIGH($8000) ; iOBJInfo_VRAMPtr_High
	db BANK(OBJLstPtrTable_Title)
	db LOW(OBJLstPtrTable_Title)
	db HIGH(OBJLstPtrTable_Title)
	db TITLE_OBJ_PUSHSTART*OBJLSTPTR_ENTRYSIZE ; iOBJInfo_OBJLstPtrTblOffset
	db $00 ; iOBJInfo_BankNumView
	db LOW(OBJLstPtrTable_Title) ; iOBJInfo_OBJLstPtrTbl_LowView
	db HIGH(OBJLstPtrTable_Title) ; iOBJInfo_OBJLstPtrTbl_HighView
	db $00 ; iOBJInfo_OBJLstPtrTblOffset
	db $00 ; iOBJInfo_ColiBoxId (auto)
	db $00 ; iOBJInfo_HitboxId (auto)
	db $00 ; iOBJInfo_ForceHitboxId
	db $00 ; iOBJInfo_FrameLeft
	db $00 ; iOBJInfo_FrameTotal
	db LOW(wGFXBufInfo_Pl1) ; iOBJInfo_BufInfoPtr_Low
	db HIGH(wGFXBufInfo_Pl1) ; iOBJInfo_BufInfoPtr_High

OBJLstPtrTable_Title:
	dw OBJLstHdrA_Title_PushStart, OBJLSTPTR_NONE
	dw OBJLstHdrA_Title_Menu, OBJLSTPTR_NONE ; GAME SELECT / OPTIONS
	dw OBJLstHdrA_Title_CursorR, OBJLSTPTR_NONE
	dw OBJLstHdrA_Title_SNKCopyright, OBJLSTPTR_NONE
	dw OBJLstHdrA_Title_CursorU, OBJLSTPTR_NONE
	dw $FFFF
		
OBJLstHdrA_Title_PushStart:
	db OLF_NOBUF ; iOBJLstHdrA_Flags
	db $00 ; iOBJLstHdrA_ColiBoxId
	db $00 ; iOBJLstHdrA_HitBoxId
	db $FF,$FF,$FF ; iOBJLstHdrA_GFXPtr + iOBJLstHdrA_GFXBank
	dw .bin ; iOBJLstHdrA_DataPtr
	db $00 ; iOBJLstHdrA_XOffset
	db $00 ; iOBJLstHdrA_YOffset
.bin:
	db $09 ; OBJ Count
	;    Y   X  ID+FLAG
	db $34,$00,$10 ; $00
	db $34,$08,$18 ; $01
	db $34,$10,$14 ; $02
	db $34,$18,$06 ; $03
	db $34,$28,$14 ; $04
	db $34,$30,$16 ; $05
	db $34,$38,$00 ; $06
	db $34,$40,$12 ; $07
	db $34,$48,$16 ; $08
		
OBJLstHdrA_Title_Menu:
	db OLF_NOBUF ; iOBJLstHdrA_Flags
	db $00 ; iOBJLstHdrA_ColiBoxId
	db $00 ; iOBJLstHdrA_HitBoxId
	db $FF,$FF,$FF ; iOBJLstHdrA_GFXPtr + iOBJLstHdrA_GFXBank
	dw .bin ; iOBJLstHdrA_DataPtr
	db $00 ; iOBJLstHdrA_XOffset
	db $00 ; iOBJLstHdrA_YOffset
.bin:
	db $0F ; OBJ Count
	;    Y   X  ID+FLAG
	db $38,$00,$0E ; $00
	db $38,$08,$10 ; $01
	db $38,$10,$16 ; $02
	db $38,$18,$08 ; $03
	db $38,$20,$0E ; $04
	db $38,$28,$0C ; $05
	db $30,$00,$04 ; $06
	db $30,$08,$00 ; $07
	db $30,$10,$0A ; $08
	db $30,$18,$02 ; $09
	db $30,$28,$14 ; $0A
	db $30,$30,$16 ; $0B
	db $30,$38,$00 ; $0C
	db $30,$40,$12 ; $0D
	db $30,$48,$16 ; $0E
		
OBJLstHdrA_Title_CursorR:
	db OLF_NOBUF ; iOBJLstHdrA_Flags
	db $00 ; iOBJLstHdrA_ColiBoxId
	db $00 ; iOBJLstHdrA_HitBoxId
	db $FF,$FF,$FF ; iOBJLstHdrA_GFXPtr + iOBJLstHdrA_GFXBank
	dw .bin ; iOBJLstHdrA_DataPtr
	db $00 ; iOBJLstHdrA_XOffset
	db $00 ; iOBJLstHdrA_YOffset
.bin:
	db $01 ; OBJ Count
	;    Y   X  ID+FLAG
	db $30,$F6,$1A ; $00
		
OBJLstHdrA_Title_CursorU:
	db OLF_NOBUF ; iOBJLstHdrA_Flags
	db $00 ; iOBJLstHdrA_ColiBoxId
	db $00 ; iOBJLstHdrA_HitBoxId
	db $FF,$FF,$FF ; iOBJLstHdrA_GFXPtr + iOBJLstHdrA_GFXBank
	dw .bin ; iOBJLstHdrA_DataPtr
	db $00 ; iOBJLstHdrA_XOffset
	db $00 ; iOBJLstHdrA_YOffset
.bin:
	db $01 ; OBJ Count
	;    Y   X  ID+FLAG
	db $30,$F8,$1C ; $00
		
OBJLstHdrA_Title_SNKCopyright:
	db OLF_NOBUF ; iOBJLstHdrA_Flags
	db $00 ; iOBJLstHdrA_ColiBoxId
	db $00 ; iOBJLstHdrA_HitBoxId
	db $FF,$FF,$FF ; iOBJLstHdrA_GFXPtr + iOBJLstHdrA_GFXBank
	dw .bin ; iOBJLstHdrA_DataPtr
	db $00 ; iOBJLstHdrA_XOffset
	db $00 ; iOBJLstHdrA_YOffset
.bin:
	db $06 ; OBJ Count
	;    Y   X  ID+FLAG
	db $48,$00,$1E ; $00
	db $48,$08,$20 ; $01
	db $48,$10,$22 ; $02
	db $48,$18,$24 ; $03
	db $48,$20,$26 ; $04
	db $48,$28,$28 ; $05

TextDef_Menu_Title:
	dw $98C4
	db $0B
	db "GAME SELECT"
TextDef_Menu_SinglePlay:
	dw $9924
	db $0B
	db "SINGLE PLAY"
TextDef_Menu_TeamPlay:
	dw $9964
	db $09
	db "TEAM PLAY"
TextDef_Menu_SingleVS: 
	dw $99A4
	db $09
	db "SINGLE VS"
TextDef_Menu_TeamVS:
	dw $99E4
	db $07
	db "TEAM VS"
TextDef_Options_Title:
	dw $98B7
	db $06
	db "OPTION"
TextDef_Options_Time:
	dw $98F4
	db $0C
	db "TIME      XX"
TextDef_Options_Level:
	dw $9934
	db $0C
	db "LEVEL NORMAL"
TextDef_Options_BGMTest:
	dw $9974
	db $0C
	db "BGM TEST  XX"
TextDef_Options_SFXTest:
	dw $99B4
	db $0C
	db "S.E.TEST  XX"
TextDef_Options_SGBSndTest:
	dw $99F4
	db $0C
	db "SGB S.E.TEST"
TextDef_Options_Exit:
	dw $9A94
	db $04
	db "EXIT"
TextDef_Options_Dip:
	dw $9AB8
	db $08
	db "DIPSW-00"
TextDef_Options_Off:
	dw $98FD
	db $03
	db "OFF"
; Removes the O from OFF when printing a number
TextDef_Options_ClrOff:
	dw $98FD
	db $01
	db " "
TextDef_Options_Easy:
	dw $993A
	db $06
	db "  EASY"
TextDef_Options_Normal:
	dw $993A
	db $06
	db "NORMAL"
TextDef_Options_Hard:
	dw $993A
	db $06
	db "  HARD"
TextDef_Options_SGBSndTypes:
	dw $9A36
	db $0A
	db "SE-A  SE-B"
TextDef_Options_SGBSndPlaceholders: 
	dw $9A56
	db $0A
	db "XX X  XX X"
; NumberPrinter_Instant always prints two digits.
; These spaces are used to cover the upper digit for the SGB sound test.
TextDef_Options_ClrSGBSndA:
	dw $9A58
	db $01
	db " "
TextDef_Options_ClrSGBSndB:
	dw $9A5E
	db $01
	db " "
	
; =============== SGBPacket_Options_PlaySnd ===============
; Used to play a SGB sound in the SGB Sound Test.
; This is copied to RAM to allow updating the bytes marking the Sound IDs to play.

SGBPacketDef_Options_PlaySnd: 
	db SGBPacket_Options_PlaySnd.end-SGBPacket_Options_PlaySnd ; Copy $10 bytes
SGBPacket_Options_PlaySnd:
	pkg SGB_PACKET_SOUND, $01
	db $00 ; wOptionsSGBPacketSndIdAA
	db $00 ; wOptionsSGBPacketSndIdAB
	db $00
	db $00
	db $00
	db $00
	db $00
	db $00
	db $00
	db $00
	db $00
	db $00
	db $00
	db $00
	db $00
.end:

; =============== SGBPacket_Options_StopSnd ===============
; Used to stop any SGB Sound currently playing.
SGBPacket_Options_StopSnd:
	pkg SGB_PACKET_SOUND, $01
	db $80 ; Stop A
	db $80 ; Stop B
	db $00
	db $00
	db $00
	db $00
	db $00
	db $00
	db $00
	db $00
	db $00
	db $00
	db $00
	db $00
	db $00

; =============== Title_DisableSerial ===============
Title_DisableSerial:
	xor  a
	ldh  [rSB], a
	ld   [wSerialDataReceiveBuffer], a
	ld   [wSerialPlayerId], a
	ld   [wSerialTransferDone], a
	ld   [wSerialDataSendBuffer], a
	ret
	
; =============== ModeSelect_SetSerialIdle ===============
; Marks that the GB is ready to listen to the other player.
ModeSelect_SetSerialIdle:
	; Prepare default the serial settings with what we're replying to 
	; if the other GB sends something through serial.
	ld   a, MODESELECT_SBCMD_IDLE			; Set idle flag
	ldh  [rSB], a							; It will be checked by the other GB in ModeSelect_TrySendVSData
	ld   a, START_TRANSFER_EXTERNAL_CLOCK	; Autoreply MODESELECT_SBCMD_IDLE when the other GB sends something
	ldh  [rSC], a
	ret
	
; =============== ModeSelect_Serial_SendAndWait ===============
; Sends a byte through the serial cable, and waits a reply from the other GB.
; This marks us as master, overwriting what was set in ModeSelect_SetSerialIdle.
; IN
; - A: Byte to send (MODESELECT_SBCMD_*)
ModeSelect_Serial_SendAndWait:
	ldh  [rSB], a
	ld   a, START_TRANSFER_INTERNAL_CLOCK	; Start master transfer
	ldh  [rSC], a
	
	
; =============== ModeSelect_Serial_Wait ===============
; Waits for a byte to be fully received.
ModeSelect_Serial_Wait:
	ld   a, [wSerialTransferDone]
	and  a							; Are we done?
	jr   z, ModeSelect_Serial_Wait	; If not, wait
	xor  a							; Reset marker before exit
	ld   [wSerialTransferDone], a
	ret
	
; =============== ModeSelect_TrySendVSData ===============
; Attempts to send the additional data to sync up both players.
; OUT
; - A: Value received from the slave
ModeSelect_TrySendVSData:
	; [Master 1/3 Recv] If the slave didn't isn't ready (see: not at the Mode Select menu), return
	ld   a, [wSerialDataReceiveBuffer]
	cp   MODESELECT_SBCMD_IDLE			; RecByte == MODESELECT_SBCMD_IDLE?
	jr   z, .send						; If so, jump
	ret
.send: 
	; Save the received byte for later in wSerialPlayerId.
	; This also has the effect of always writing SERIAL_PL1_ID, marking the current
	; player as being 1P / using hJoyKeys for the serial input handler.
	;
	; This works because only the master can ever write MODESELECT_SBCMD_IDLE here (which has the same value as SERIAL_PL1_ID),
	; while the slave can only write in ModeSelect_GetCtrlFromSerial the command IDs we send
	; (MODESELECT_SBCMD_TEAMVS or MODESELECT_SBCMD_SINGLEVS).
	ld   [wSerialPlayerId], a 		; Save received byte
	
	; Set ourselves as master
	ld   hl, wMisc_C025
	set  MISCB_SERIAL_MODE, [hl]
	res  MISCB_SERIAL_SLAVE, [hl]
	
	; Wait for a bit.
	; This also disables wSerialTransferDone on VBlank.
	call Task_PassControl_NoDelay
	call Task_PassControl_NoDelay
	call Task_PassControl_NoDelay
	
	; [Master 2/3] Send out the timer setting and wait some more
	ld   a, [wMatchStartTime]
	call ModeSelect_Serial_SendAndWait
	; Wait for a bit and reset wSerialTransferDone
	call Task_PassControl_NoDelay
	call Task_PassControl_NoDelay
	call Task_PassControl_NoDelay
	
	; [Master 3/3] Send out the dip settings (unlocked chars, etc...)
	ld   a, [wDipSwitch]
	call ModeSelect_Serial_SendAndWait
	
	ld   a, [wSerialPlayerId]		; Restore received byte
	ret  
	
; =============== ModeSelect_GetCtrlFromSerial ===============
; Listens to the serial port to check if the other player selected a VS mode.
; If so, it syncs up the options.
; OUT
; - A: Action id (MODESELECT_SBCMD_*) received by master, if it's there
ModeSelect_GetCtrlFromSerial:
	; If we were sent a VS Mode option ID, also listen to the next two settings bytes.
	ld   a, [wSerialDataReceiveBuffer] ; A = Value from master
	cp   MODESELECT_SBCMD_TEAMVS			
	jr   z, .receiveVSData
	cp   MODESELECT_SBCMD_SINGLEVS
	jr   z, .receiveVSData
	; Otherwise, nothing happened.
	ret
.receiveVSData:
	; Save the MODESELECT_ACT_* value we were sent here.
	; This also has the effect of marking the current player as being 2P / using hJoyKeys2.
	; See also: ModeSelect_TrySendVSData.
	ld   [wSerialPlayerId], a
	
	; Set ourselves as slave, since we're on the receiving end.
	ld   hl, wMisc_C025
	set  MISCB_SERIAL_MODE, [hl]
	set  MISCB_SERIAL_SLAVE, [hl]
	
	; [Slave 2/3] Wait for the other GB to send wMatchStartTime
	xor  a
	ld   [wSerialTransferDone], a
	call ModeSelect_Serial_Wait
	ld   a, [wSerialDataReceiveBuffer]
	ld   [wMatchStartTime], a
	
	; [Slave 3/3] Wait for the other GB to send wDipSwitch
	xor  a
	ld   [wSerialTransferDone], a
	call ModeSelect_Serial_Wait
	ld   a, [wSerialDataReceiveBuffer]
	ld   [wDipSwitch], a
	
	; Return the action ID
	ld   a, [wSerialPlayerId]		; Restore MODESELECT_ACT_* value
	ret  

; =============== Title_LoadVRAM ===============
; Loads tilemaps and GFX for the title screen.
; The menus load the 1bpp text over this, and reuse the cursor already loaded here.
Title_LoadVRAM:
	; Title screen & menu sprites
	ld   hl, GFXAuto_TitleOBJ 
	ld   de, Tiles_Begin		
	call CopyTilesAutoNum
	
	; wLZSS_Buffer offset by $10 since a SGB packet got copied at the start of the buffer.
	
	; KOF96 Title logo tilemap
	ld   hl, BGLZ_Title_Logo
	ld   de, wLZSS_Buffer+$10
	call DecompressLZSS
	ld   de, wLZSS_Buffer+$10
	ld   hl, WINDOWMap_Begin
	ld   b, $14
	ld   c, $0F
	call CopyBGToRect
	
	; Title screen logo GFX (2 parts)
	ld   hl, GFXLZ_Title_Logo1
	ld   de, wLZSS_Buffer+$10
	call DecompressLZSS
	ld   hl, wLZSS_Buffer+$10
	ld   de, $8800				; Block 2
	ld   b, $80
	call CopyTiles
	
	ld   hl, GFXLZ_Title_Logo0
	ld   de, wLZSS_Buffer+$10
	call DecompressLZSS
	ld   hl, wLZSS_Buffer+$10
	ld   de, $9000				; Block 3
	ld   b, $80
	call CopyTiles
	
	; Tilemap in BG layer for cloud parallax, repeated to fill the tilemap's width
I = 0
REPT 8
	ld   de, BG_Title_Clouds
	ld   hl, BGMap_Begin+($04*I)
	ld   b, $04	; 4 tiles width * 8 = $20 (tilemap length)
	ld   c, $03 ; 3 tiles tall
	call CopyBGToRect
I = I + 1
ENDR
	ret
	
; =============== Title_LoadVRAM_Mini ===============
; Loads the title screen GFX which were overwritten by the 1bpp font.
Title_LoadVRAM_Mini:
	; Title screen logo GFX (2nd part, at $9000)
	
	; This takes advantage that GFXLZ_Title_Logo0 was the last LZSS data to be decompressed.
	; As a result, the decompressed copy is still stored in the buffer.

	ld   hl, wLZSS_Buffer+$10	; HL = Source
	ld   de, $9000				; DE = Destination
	ld   b, $80					; B = Tiles to copy
	call CopyTilesHBlank
	ret
	
GFXLZ_Title_Logo0: INCBIN "data/gfx/title_logo0.lzc"
GFXLZ_Title_Logo1: INCBIN "data/gfx/title_logo1.lzc"
BGLZ_Title_Logo: INCBIN "data/bg/title_logo.lzs"
BG_Title_Clouds: INCBIN "data/bg/title_clouds.bin"

GFXAuto_TitleOBJ:
	db (GFXAuto_TitleOBJ.end-GFXAuto_TitleOBJ.start)/TILESIZE ; Number of tiles
.start:
	INCBIN "data/gfx/title_obj.bin"
.end:

; 
; =============== END OF MODULE TitleMenu ===============
;



; 
; =============== START OF MODULE Intro ===============
;
; =============== Module_Intro ===============
; EntryPoint for Intro. Called by rst $00 jump from Module_TakaraLogo.
L1C5FD2:
Module_Intro:
	ld   sp, $DD00
	di
	;-----------------------------------
	rst  $10				; Stop LCD
	
	ld   hl, wMisc_C028
	res  MISCB_PL_RANGE_CHECK, [hl]
	
	; Reset DMG Pal & vars
	xor  a
	ldh  [rBGP], a
	ldh  [rOBP0], a
	ldh  [rOBP1], a
	ld   [wIntroScene], a
	
	; Don't execute special code
	ld   a, TXB_NONE
	ld   [wTextPrintFrameCodeBank], a
	
	ld   de, SCRPAL_INTRO
	call HomeCall_SGB_ApplyScreenPalSet
	
	; Reset screen & coords
	call ClearBGMap
	call ClearWINDOWMap
	
	xor  a
	ldh  [hScrollX], a
	ldh  [hScrollY], a
	ld   [wOBJScrollX], a
	ld   [wOBJScrollY], a
	
	call LoadGFX_1bppFont_Default
	call ClearOBJInfo
	
	; Hide WINDOW
	ld   a, $90
	ldh  [rWY], a
	ld   a, $07
	ldh  [rWX], a
	
	ld   a, LCDC_PRIORITY|LCDC_OBJENABLE|LCDC_OBJSIZE|LCDC_WENABLE|LCDC_WTILEMAP|LCDC_ENABLE
	rst  $18				; Resume LCD
	;-----------------------------------
	ei
	
	; Wait $3C frames
	ld   b, $3C
.wait0:
	call Task_PassControl_NoDelay
	dec  b
	jp   nz, .wait0
	
	
	ld   a, $3F			; [POI] Overwritten
	
	; Set DMG pal
	ld   a, $18
	ldh  [rOBP0], a
	ld   a, $00
	ldh  [rOBP1], a
	ld   a, $1B
	ldh  [rBGP], a
	
.mainLoop:
	;
	; Main loop of the intro.
	; Each intro scene is its own submodule which take over control.
	; Only when they are done, they return to this loop.
	;
	
	;--
	; [POI] This is practically impossible to trigger here.
	call Intro_Base_IsStartPressed	; Did we abort prematurely?
	jp   c, Intro_End				; If so, end the intro.
	;--
	
	; Execute the scene
	ld   a, [wIntroScene]
	ld   hl, Intro_ScenePtrTable
	call Intro_ExecScene
	; If that was the last scene or we ended prematurely (C flag set), end the intro
	jp   c, Intro_End
	call Task_PassControl_NoDelay
	jp   .mainLoop
	
; =============== Intro_ExecScene ===============
; DynJump using the specified jump table and offset.
; Used for jumping to init code of a specific scene or subscene.
; IN
; - A: Scene or subscene "ID" (offset to ptr table)
; - HL: Ptr to Scene Ptr Table
Intro_ExecScene:
	ld   d, $00		; DE = A
	ld   e, a
	add  hl, de		; Offset it
	ld   e, [hl]	; Read out ptr to DE
	inc  hl
	ld   d, [hl]
	push de			; Move it to HL and jump there
	pop  hl
	jp   hl
; =============== Intro_End ===============	
; Switches to the title screen mode.
Intro_End:
	; Blank palette
	ld   a, $FF
	ldh  [rBGP], a
	ldh  [rOBP0], a
	ldh  [rOBP1], a
	
	; Disable LYC
	xor  a
	ldh  [rSTAT], a
	
	ld   [wGFXBufInfo_Pl1+iGFXBufInfo_TilesLeftA], a
	ld   [wGFXBufInfo_Pl1+iGFXBufInfo_TilesLeftB], a
	ld   [wGFXBufInfo_Pl2+iGFXBufInfo_TilesLeftA], a
	ld   [wGFXBufInfo_Pl2+iGFXBufInfo_TilesLeftB], a
	
	; Jump to title screen
	ld   b, BANK(Module_Title)
	ld   hl, Module_Title
	rst  $00
	
Intro_ScenePtrTable:
	dw IntroScene_TextPrint ; Text print
	dw IntroScene_Chars ; Char sprites animating (including the scene after Iori rises)
	dw IntroScene_IoriRise ; Iori rising
	dw IntroScene_IoriKyo ; Iori / Kyo scene
	
; =============== IntroScene_TextPrint ===============
; Prints the intro text to the screen.
; OUT
; - C flag: If set, end the intro prematurely
IntroScene_TextPrint:
	ld   hl, IntroTextPtrTable
	ld   b, [hl]			; B = Number of string/TextDef pointers
	inc  hl					
.loop:
	push bc
		push hl
			
			; HL = Ptr to TextDef structure
			ld   e, [hl]		
			inc  hl
			ld   d, [hl]
			push de
			pop  hl
			
			; Print the string from the intro
			ld   b, BANK(IntroTextPtrTable) ; Bank with strings
			ld   c, $04 ; 4 frame delay between letters
			ld   a, TXT_PLAYSFX|TXT_ALLOWSKIP 	; Flags
			call TextPrinter_MultiFrameFar		; Do it
			jr   c, .abort						; Did we abort the printing? If so, jump
			
			; Wait $14 frames before clearing the screen, while that happens
			; still listen to abort requests
			ld   a, $14
			call Intro_ChkStartPressed_MultiFrame
			call ClearBGMap
		pop  hl
		inc  hl		; Next TextDef ptr
		inc  hl
	pop  bc
	dec  b				; Processed all strings?
	jr   nz, .loop		; If not, loop
.done:
	; Wait $3C frames on the black screen
	ld   a, $3C
	call Intro_ChkStartPressed_MultiFrame
	
	; Prepare next scene
	ld   a, BGM_IN1996
	call HomeCall_Sound_ReqPlayExId_Stub
	call Intro_CharS_LoadVRAM
	ld   a, ISC_CHAR
	ld   [wIntroScene], a
	ret
.abort:
	; Set C flag to end the intro
	pop  hl
	pop  bc
	scf
	ret

; =============== IntroScene_Chars ===============
; Animates character sprites while moving rectangles across the screen.
; OUT
; - C flag: If set, end the intro prematurely
IntroScene_Chars:
	; Use wIntroCharScene as offset to the jump table Intro_CharScene_PtrTable.
	; There are also a few special cases for exiting to different intro scenes.
	
	ld   a, [wIntroCharScene]
	cp   ISCC_CHG_IORIRISE	; SceneId == $1C?
	jr   z, .startIoriRise	; If so, jump
	cp   ISCC_CHG_IORIKYO	; SceneId == $26?
	jr   z, .startIoriKyo	; If so, jump
.dynJump:
	ld   hl, Intro_CharScene_PtrTable
	call Intro_ExecScene
	jr   IntroScene_Chars	; Handle next
	
.startIoriRise:
	; Prepare VRAM and exit
	; (we disabled player sprites at the end of Intro_CharScene_Mature)
	call Intro_IoriRise_LoadVRAM
	ld   a, ISC_IORIRISE
	ld   [wIntroScene], a
	xor  a
	ret
	
.startIoriKyo:
	; Disable player sprites, they aren't needed anymore
	ld   hl, wOBJInfo_Pl1+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	ld   hl, wOBJInfo_Pl2+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	; Prepare VRAM and exit
	call Intro_IoriKyo_LoadVRAM
	ld   a, ISC_IORIKYO		
	ld   [wIntroScene], a
	xor  a
	ret
	
Intro_CharScene_PtrTable:
	dw Intro_CharScene_Init
	dw Intro_CharScene_Terry
	dw Intro_CharScene_Andy
	dw Intro_CharScene_Mai
	dw Intro_CharScene_Athena
	dw Intro_CharScene_Leona
	dw Intro_CharScene_Robert
	dw Intro_CharScene_Ryo
	dw Intro_CharScene_MrKarate
	dw Intro_CharScene_MrBig
	dw Intro_CharScene_Geese
	dw Intro_CharScene_Krauser
	dw Intro_CharScene_Daimon
	dw Intro_CharScene_Mature
	dw $0000 ; N/A
	dw Intro_CharScene_Kyo
	dw Intro_CharScene_IoriKyoA
	dw Intro_CharScene_IoriKyoB
	dw Intro_CharScene_IoriKyoC
	
; =============== Intro_CharScene_Init ===============
; Init code for the Terry scene.
Intro_CharScene_Init:
	ld   a, $FF				; Clear BG Palette
	ldh  [rBGP], a
	
	;
	; The way the intro backgrounds work is a combination of moving the screen
	; (while keeping the sprites at the same positions) and updating the tilemap
	; when shrinking the white cut-in.
	;

	; Fill the screen with a black tile that hides sprites
	ld   d, TILE_INTRO_BLACK				
	call ClearBGMapCustom

	; Draw a full (visible) screen white rectangle off-screen where sprites inside are visible.
	; This will be later moved upwards by scrolling the screen down.
	ld   hl, $9A40 ; Left corner pos
	ld   b, $14 ; Rect Width
	ld   c, $06 ; Rect Height
	ld   d, TILE_INTRO_WHITE ; Tile ID
	call FillBGRect
	
	; Set Terry sprite pos
	ld   a, $20
	ld   [wOBJInfo_Pl1+iOBJInfo_X], a
	ld   a, $00
	ld   [wOBJInfo_Pl1+iOBJInfo_Y], a
	
	; Set Andy sprite pos
	ld   a, $80
	ld   [wOBJInfo_Pl2+iOBJInfo_X], a
	ld   a, $40
	ld   [wOBJInfo_Pl2+iOBJInfo_Y], a
	
	; Screen in top left corner
	xor  a
	ldh  [hScrollX], a
	ldh  [hScrollY], a
	
	; Next scene
	ld   a, [wIntroCharScene]
	add  a, $02
	ld   [wIntroCharScene], a
	
	ld   a, $01
	call Intro_ChkStartPressed_MultiFrame
	
	; Enable Terry sprite
	ld   hl, wOBJInfo_Pl1+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]
	
	ld   a, $F0				; Set actual BG Palette
	ldh  [rBGP], a
	ret
	
; =============== Intro_CharScene_Terry ===============
; Terry scene.
Intro_CharScene_Terry:
	; Move white bar up $10*$10 px
	ld   a, $10
	call Intro_CharS_MoveBGUp_MultiFrame
	
	; Show Andy
	ld   hl, wOBJInfo_Pl2+iOBJInfo_Status
	set  OSTB_VISIBLE, [hl]
	
	; Wait $0F frames animating chars
	ld   a, $0F
	call Intro_CharS_WaitVBlank
	
	jp   Intro_CharS_NextMode
	
; =============== Intro_CharScene_Andy ===============
; Andy scene.
Intro_CharScene_Andy:

	; Move white bar down $0B*$0B px
	ld   a, $0B
	call Intro_CharS_MoveBGDown_MultiFrame
	
	; Shrink left side $0D tiles
	ld   a, $0D ; Black out $0D columns
	ld   b, $01 ; Width
	ld   c, $06 ; Height
	ld   d, TILE_INTRO_BLACK ; Tile ID
	ld   hl, $9A40 ; Origin
	call Intro_CharS_FillBGRectRight_MultiFrame
	
	; Shrink right side $02 tiles
	ld   a, $02
	ld   b, $01
	ld   c, $06
	ld   d, TILE_INTRO_BLACK
	ld   hl, $9A53
	call Intro_CharS_FillBGRectLeft_MultiFrame
	
	; Grow bottom side
	ld   a, $03
	ld   b, $05
	ld   c, $01
	ld   d, TILE_INTRO_WHITE
	ld   hl, $9B0D
	call Intro_CharS_FillBGRectDown_MultiFrame
	
	; Grow top side
	ld   a, $0B
	ld   b, $05
	ld   c, $01
	ld   d, TILE_INTRO_WHITE
	ld   hl, $9A4D
	call Intro_CharS_FillBGRectUp_MultiFrame
	
	; Wait $0F frames
	ld   a, $0F
	call Intro_CharS_WaitVBlank
	
	; Next scene
	call Intro_CharS_SetNextChar
	jp   Intro_CharS_NextMode
	
; =============== Intro_CharScene_Mai ===============
; Mai scene.
Intro_CharScene_Mai:
	; Move white section to the middle
	ld   a, $09
	call Intro_CharS_MoveBGLeft_MultiFrame
	
	ld   a, $0F
	call Intro_CharS_WaitVBlank
	
	call Intro_CharS_SetNextChar
	jp   Intro_CharS_NextMode
	
; =============== Intro_CharScene_Athena ===============
; Athena scene.
Intro_CharScene_Athena:
	; Move white section to the left
	ld   a, $09
	call Intro_CharS_MoveBGLeft_MultiFrame
	
	ld   a, $0F
	call Intro_CharS_WaitVBlank
	
	call Intro_CharS_SetNextChar
	jp   Intro_CharS_NextMode
	
; =============== Intro_CharScene_Leona ===============
; Leona scene.
Intro_CharScene_Leona:
	; Move white section to the middle
	ld   a, $09
	call Intro_CharS_MoveBGRight_MultiFrame
	
	; Shrink from below
	ld   a, $04
	ld   b, $05
	ld   c, $01
	ld   d, TILE_INTRO_BLACK
	ld   hl, $9B6D
	call Intro_CharS_FillBGRectUp_MultiFrame
	
	; Shrink from above
	ld   a, $0A
	ld   b, $05
	ld   c, $01
	ld   d, TILE_INTRO_BLACK
	ld   hl, $990D
	call Intro_CharS_FillBGRectDown_MultiFrame
	
	; Hide Athena
	ld   hl, wOBJInfo_Pl2+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	
	; Expand horizontally to full screen
	ld   a, $08
	ld   c, $06
	ld   hl, $9A4C
	ld   de, $9A52
	call Intro_CharS_CropOpenH_MultiFrame
	
	ld   a, $0A
	call Intro_CharS_WaitVBlank
	call Intro_CharS_SetNextChar
	jp   Intro_CharS_NextMode
; =============== Intro_CharScene_Robert ===============
; Robert scene.
Intro_CharScene_Robert:
	; Move bar up near the top
	ld   a, $0B
	call Intro_CharS_MoveBGUp_MultiFrame
	
	ld   a, $0F
	call Intro_CharS_WaitVBlank
	call Intro_CharS_SetNextChar
	jp   Intro_CharS_NextMode
; =============== Intro_CharScene_Ryo ===============
; Ryo scene.
Intro_CharScene_Ryo:
	; Move bar down near the bottom
	ld   a, $0C
	call Intro_CharS_MoveBGDown_MultiFrame
	
	ld   a, $0F
	call Intro_CharS_WaitVBlank
	call Intro_CharS_SetNextChar
	jp   Intro_CharS_NextMode
; =============== Intro_CharScene_MrKarate ===============
; Mr. Karate scene.
Intro_CharScene_MrKarate:
	; Move bar up at the middle
	ld   a, $09
	call Intro_CharS_MoveBGUp_MultiFrame
	
	ld   a, $0F
	call Intro_CharS_WaitVBlank
	
	; Completely close vertically
	ld   a, $03
	ld   hl, $9A45
	ld   de, $9AE5
	call Intro_CharS_CropCloseH_MultiFrame
	
	call Intro_CharS_SetNextChar
	jp   Intro_CharS_NextMode
; =============== Intro_CharScene_MrBig ===============
; Mr. Big scene.
Intro_CharScene_MrBig:

	; Use the opportunity of the tilemap being completely black to reset the X scroll
	xor  a
	ldh  [hScrollX], a
	
	; Open window with Mr. Big on the left
	ld   a, $05
	ld   b, $01
	ld   c, $06
	ld   d, TILE_INTRO_WHITE
	ld   hl, $9A45
	call Intro_CharS_FillBGRectLeft_MultiFrame
	
	ld   a, $0F
	call Intro_CharS_WaitVBlank
	
	; Completely close window we just opened
	ld   a, $05
	ld   b, $01
	ld   c, $06
	ld   d, TILE_INTRO_BLACK
	ld   hl, $9A45
	call Intro_CharS_FillBGRectLeft_MultiFrame
	
	call Intro_CharS_SetNextChar
	jp   Intro_CharS_NextMode
; =============== Intro_CharScene_Geese ===============
; Geese scene.
Intro_CharScene_Geese:

	; Open window on the right
	ld   a, $05
	ld   b, $01
	ld   c, $06
	ld   d, TILE_INTRO_WHITE
	ld   hl, $9A4E
	call Intro_CharS_FillBGRectRight_MultiFrame
	
	ld   a, $0F
	call Intro_CharS_WaitVBlank
	
	; Close it
	ld   a, $05
	ld   b, $01
	ld   c, $06
	ld   d, TILE_INTRO_BLACK
	ld   hl, $9A4E
	call Intro_CharS_FillBGRectRight_MultiFrame
	
	call Intro_CharS_SetNextChar
	jp   Intro_CharS_NextMode
; =============== Intro_CharScene_Krauser ===============
; Krauser scene.
Intro_CharScene_Krauser:
	; Move slightly left to center the window
	ld   a, $FC
	ldh  [hScrollX], a
	
	; Open window at the center
	ld   a, $06
	ld   b, $05
	ld   c, $01
	ld   d, TILE_INTRO_WHITE
	ld   hl, $9AE7
	call Intro_CharS_FillBGRectUp_MultiFrame
	
	ld   a, $0F
	call Intro_CharS_WaitVBlank
	
	; Close it
	ld   a, $06
	ld   b, $05
	ld   c, $01
	ld   d, TILE_INTRO_BLACK
	ld   hl, $9AE7
	call Intro_CharS_FillBGRectUp_MultiFrame
	
	call Intro_CharS_SetNextChar
	jp   Intro_CharS_NextMode
; =============== Intro_CharScene_Daimon ===============
; Daimon scene.
Intro_CharScene_Daimon:
	; Reset coords to top-left
	xor  a
	ldh  [hScrollX], a
	ldh  [hScrollY], a
	
	; Open tall section on the right side
	ld   a, $05
	ld   b, $01
	ld   c, $12
	ld   d, TILE_INTRO_WHITE
	ld   hl, $980E
	call Intro_CharS_FillBGRectRight_MultiFrame
	
	ld   a, $0F
	call Intro_CharS_WaitVBlank
	
	; Close section
	ld   a, $05
	ld   b, $01
	ld   c, $12
	ld   d, TILE_INTRO_BLACK
	ld   hl, $980E
	call Intro_CharS_FillBGRectRight_MultiFrame
	
	call Intro_CharS_SetNextChar
	jp   Intro_CharS_NextMode
; =============== Intro_CharScene_Mature ===============
; Mature scene.
Intro_CharScene_Mature:
	; Open tall section on the left side
	ld   a, $05
	ld   b, $01
	ld   c, $12
	ld   d, TILE_INTRO_WHITE
	ld   hl, $9805
	call Intro_CharS_FillBGRectLeft_MultiFrame
	
	ld   a, $0F
	call Intro_CharS_WaitVBlank
	
	; Close section
	ld   a, $05
	ld   b, $01
	ld   c, $12
	ld   d, TILE_INTRO_BLACK
	ld   hl, $9805
	call Intro_CharS_FillBGRectLeft_MultiFrame
	
	; Hide player sprites since we're moving to ISC_IORIRISE
	ld   hl, wOBJInfo_Pl1+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	ld   hl, wOBJInfo_Pl2+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	
	; Flip both sprites for Intro_CharScene_Kyo, to make Iori and Kyo face each other
	ld   a, [wOBJInfo_Pl1+iOBJInfo_OBJLstFlags] ; Make Kyo face left
	xor  OST_XFLIP
	ld   [wOBJInfo_Pl1+iOBJInfo_OBJLstFlags], a
	ld   a, [wOBJInfo_Pl2+iOBJInfo_OBJLstFlags] ; Make Kyo face right
	xor  OST_XFLIP
	ld   [wOBJInfo_Pl2+iOBJInfo_OBJLstFlags], a
	
	jp   Intro_CharS_NextMode
; =============== Intro_CharScene_Kyo ===============
; Kyo scene.
Intro_CharScene_Kyo:

	; Reset coords
	xor  a
	ldh  [hScrollX], a
	ldh  [hScrollY], a
	
	; Open tall section on the right side
	ld   a, $05
	ld   b, $01
	ld   c, $12
	ld   d, TILE_INTRO_WHITE
	ld   hl, $980E
	call Intro_CharS_FillBGRectRight_MultiFrame
	
	ld   a, $0F
	call Intro_CharS_WaitVBlank
	
	call Intro_CharS_SetNextChar
	jp   Intro_CharS_NextMode
; =============== Intro_CharScene_IoriKyoA ===============
; Iori + Kyo sprite scene.
Intro_CharScene_IoriKyoA:
	; Open tall section on the left side
	ld   a, $05
	ld   b, $01
	ld   c, $12
	ld   d, TILE_INTRO_WHITE
	ld   hl, $9805
	call Intro_CharS_FillBGRectLeft_MultiFrame
	
	; Wait for a bit
	ld   a, $28
	call Intro_CharS_WaitVBlank
	
	; Remove left border
	ld   a, $01
	ld   b, $01
	ld   c, $12
	ld   d, TILE_INTRO_WHITE
	ld   hl, $9813
	call Intro_CharS_FillBGRectLeft_MultiFrame
	
	; Remove right border
	ld   a, $01
	ld   b, $01
	ld   c, $12
	ld   d, $00
	ld   hl, BGMap_Begin
	call Intro_CharS_FillBGRectLeft_MultiFrame
	
	call Intro_CharS_SetNextChar ; Set Kyo run anim.
	jp   Intro_CharS_NextMode
	
; =============== Intro_CharScene_IoriKyoB ===============
; Iori + Kyo sprite scene II.
Intro_CharScene_IoriKyoB:
	call Intro_CharS_SetNextChar ; Set Iori run anim
	jp   Intro_CharS_NextMode
; =============== Intro_CharScene_IoriKyoC ===============
; Iori + Kyo sprite scene III.
Intro_CharScene_IoriKyoC:

	;
	; Make the attack animations freeze at a certain point.
	; It's a little bit odd -- setting OSTB_ANIMEND prematurely will cause the
	; currently loading frame to be the last one to be applied (several frames later).
	;
	; This (with help from the animation speed definition in Intro_CharS_SetNextChar) is
	; specifically timed so that the player sprites change into a good
	; attack frame when they get to the center of the screen.
	;
	ld   a, [wOBJInfo_Pl1+iOBJInfo_OBJLstPtrTblOffset]
	cp   $04*4								; Reached frame 4? (which is still loading)
	jr   nz, .chkIori						; If not, skip
	ld   hl, wOBJInfo_Pl1+iOBJInfo_Status	; End animation. The frame will still applied when it loads.
	set  OSTB_ANIMEND, [hl]
.chkIori:;R
	ld   a, [wOBJInfo_Pl2+iOBJInfo_OBJLstPtrTblOffset]
	cp   $01*4								; Reached frame 1? (which is still loading)
	jr   nz, .waitEnd						; If not, skip
	ld   hl, wOBJInfo_Pl2+iOBJInfo_Status	; End animation. The frame will still applied when it loads.
	set  OSTB_ANIMEND, [hl]
.waitEnd:

	; Wait 1 frane
	ld   a, $01
	call Intro_CharS_WaitVBlank
	
	; Continue looping until both anims are marked as ended
	ld   a, [wOBJInfo_Pl1+iOBJInfo_Status]
	ld   b, a								; B = StatusPl1
	ld   a, [wOBJInfo_Pl2+iOBJInfo_Status]	; A = StatusPl2
	and  a, b								; 
	bit  OSTB_ANIMEND, a					; (A & B) & OSTB_ANIMEND != 0? (OSTB_ANIMEND set on both players?)
	jr   z, Intro_CharScene_IoriKyoC		; If not, loop
	
	;
	; Remove the middle black section while moving Iori and Kyo to the center of the screen.
	;
	ld   a, -$07							; Make Kyo move to the left
	ld   [wOBJInfo_Pl1+iOBJInfo_SpeedX], a
	ld   a, $07								; Make Iori move to the right
	ld   [wOBJInfo_Pl2+iOBJInfo_SpeedX], a
	
	; White out center section
	ld   a, $04
	ld   c, $12
	ld   hl, $980D
	ld   de, $9806
	call Intro_CharS_CropOpenH_MultiFrame
	
.end:
	; Reset speed
	xor  a
	ld   [wOBJInfo_Pl1+iOBJInfo_SpeedX], a
	ld   [wOBJInfo_Pl2+iOBJInfo_SpeedX], a
	
	; Wait for a bit so the last anim frames get applied
	ld   a, $0A
	call Intro_CharS_WaitVBlank
	jp   Intro_CharS_NextMode
	
; =============== Intro_CharS_NextMode ===============
; Switches to the next character scene.
Intro_CharS_NextMode:
	ld   a, [wIntroCharScene]
	add  a, $02
	ld   [wIntroCharScene], a
	ret
	
; =============== Intro_CharS_SetNextChar ===============
; Set the next player sprites on the first free slot where the win animation ended.
;
; This will update the player's sprite mappings and positions.
;
; It should be only used on players hidden behind the black background, to give
; time for the new graphics to load and to avoid having the sprite visibly change position.
Intro_CharS_SetNextChar:
	
	;
	; Get the table index and starting ptr
	;
	ld   hl, .charDefTbl			; HL = .charDefTbl
	; Generate the index to the table
	ld   a, [wIntroCharScene]	; A = (wIntroCharScene / 2) - 2
	srl  a						; /2 because it's an offset, not index
	sub  a, (ISCC_ANDY/2)		; -2 to save bytes, since the Andy scene is the first one to call this
	
	; Pick the first player slot whose animation is ended.
	;
	; Because it relies on OSTB_GFXLOAD on being cleared, care should be taken
	; to make sure the visible sprite is still animating when this is called. (more or less)
	;
	; (The win animations are set to *not* loop, so OSTB_GFXLOAD is unset when the animation ends)
	
	ld   de, wOBJInfo_Pl1+iOBJInfo_Status
	bit  OSTB_GFXLOAD, a					; GFX loading on Pl1 side?
	jr   z, .go								; If not, jump
	ld   de, wOBJInfo_Pl2+iOBJInfo_Status	; Otherwise use Pl2
.go:

	;
	; Index the table
	;
	
	; Build the index to a table with 6 byte entries
	; BC = A * 6
	sla  a			; B = A * 2		
	ld   b, a		
	sla  a			; A = A * 4
	add  b			; A += B
	ld   b, $00		; Put that in BC
	ld   c, a
	
	; Seek to the table entry
	add  hl, bc		; BC = HL + BC
	push hl
	pop  bc
	
	;
	; Update the wOBJInfo field
	;
	
	
	; Reinitialize status
	ld   a, [de]		; A = iOBJInfo_Status
	and  a, $FF^OST_ANIMEND ; Remove repeat flag
	or   a, OST_VISIBLE	    ; Force visibility
	ld   [de], a
	
	; byte0 -> iOBJInfo_BankNum
	ld   hl, iOBJInfo_BankNum	; Seek to iOBJInfo_BankNum
	add  hl, de
	ld   a, [bc]		; Read byte0
	ldi  [hl], a		; Write to iOBJInfo_BankNum
	inc  bc
	
	; byte1-2 to iOBJInfo_OBJLstPtrTbl_*0
	ld   a, [bc]
	ldi  [hl], a
	inc  bc
	ld   a, [bc]
	ldi  [hl], a
	inc  bc
	
	; $00 -> iOBJInfo_OBJLstPtrTblOffset
	xor  a
	ld   [hl], a
	
	; The target position should also hide the sprite behind the background.
	
	; byte3 -> iOBJInfo_X
	ld   hl, iOBJInfo_X	; Seek to iOBJInfo_X
	add  hl, de
	ld   a, [bc]
	ldi  [hl], a
	inc  bc
	inc  hl				; Ignore subpixel val
	
	; byte4 -> iOBJInfo_Y
	ld   a, [bc]
	ld   [hl], a
	inc  bc
	
	; Anim speed
	; byte5 -> iOBJInfo_FrameLeft & iOBJInfo_FrameTotal
	ld   hl, iOBJInfo_FrameLeft
	add  hl, de
	ld   a, [bc]
	ldi  [hl], a ; iOBJInfo_FrameLeft
	ld   [hl], a ; iOBJInfo_FrameTotal
	push de
	pop  hl	; DE = Start of wOBJInfo
	
	; Initialize animation with newly written settings
	call OBJLstS_DoAnimTiming_Initial
	
	; Wait $08 frames
	ld   a, $08
	call Intro_CharS_WaitVBlank
	ret
	
.charDefTbl:

mIntroCharDef: MACRO
	db BANK(\1)
	dw \1
	db \2,\3,\4
ENDM

	;;;;;;;;;;;;; ANIMATION TABLE       |  X|   Y| ANIMDELAY ; BANK | For Scene Loading
	mIntroCharDef L0860DC,               $50, $40,       $00 ;  $08 | ISCC_MAI        
	mIntroCharDef L08526D,               $20, $40,       $00 ;  $08 | ISCC_ATHENA     
	mIntroCharDef L0A5DBD,               $50, $40,       $03 ;  $0A | ISCC_LEONA      
	mIntroCharDef L075391,               $80, $00,       $06 ;  $07 | ISCC_ROBERT     
	mIntroCharDef L0A40FC,               $20, $50,       $04 ;  $0A | ISCC_RYO        
	mIntroCharDef L0A460C,               $50, $24,       $08 ;  $0A | ISCC_MRKARATE   
	mIntroCharDef L0770C1,               $20, $24,       $00 ;  $07 | ISCC_MRBIG      
	mIntroCharDef L076226,               $80, $24,       $00 ;  $07 | ISCC_GEESE      
	mIntroCharDef L095B53,               $50, $24,       $00 ;  $09 | ISCC_KRAUSER    
	mIntroCharDef L09409E,               $84, $40,       $00 ;  $09 | ISCC_DAIMON     
	mIntroCharDef L096891,               $1C, $40,       $06 ;  $09 | ISCC_MATURE     
	db      $00,  $00,$00,               $00, $00,       $00 ;  $00 | ISCC_CHG_IORIRISE (N/A)
	mIntroCharDef L0740F2,               $84, $40,       $00 ;  $07 | ISCC_KYO        
	mIntroCharDef L0540AC,               $1C, $40,       $00 ;  $05 | ISCC_IORIKYOA   
	mIntroCharDef L07443C,               $84, $40,       $03 ;  $07 | ISCC_IORIKYOB   
	mIntroCharDef L054464,               $1C, $40,       $0F ;  $05 | ISCC_IORIKYOC 
	
; =============== IntroScene_IoriRise ===============
; OUT
; - C flag: If set, end the intro prematurely
IntroScene_IoriRise:
	;
	; Move Iori sprite upwards for $012C frames
	;
	ld   bc, $012C		; BC = Frames to move up
.loop:
	push bc
		; Move BG Sun up at $00.04px/frame
		ld   hl, hScrollY	; Pos ptr
		ld   bc, $0004		; Speed
		call .addToPos
		
		; Move Iori up at $00.36px/frame
		ld   hl, wOBJInfo2+iOBJInfo_Y
		ld   bc, -$0036
		call .addToPos
		ld   hl, wOBJInfo3+iOBJInfo_Y
		ld   bc, -$0036
		call .addToPos
		
		; When Iori is about to overlap the Sun, disable its BG priority.
		;
		; The reason the flag is set to begin with is because, otherwise,
		; it would be visible on the lower section.
		;
		; The lower half of the sprite in wOBJInfo3 never reaches high enough,
		; so it gets to keep its BG Priority flag.
		
		ld   a, [wOBJInfo2+iOBJInfo_Y]
		cp   $30								; Has Y position $30?
		jr   nz, .noRemBGPr						; If not, skip
		ld   hl, wOBJInfo2+iOBJInfo_OBJLstFlags	; Otherwise, remove BG priority
		res  SPRB_BGPRIORITY, [hl]
	.noRemBGPr:
	
		; Wait 1 frame
		ld   a, $01
		call Intro_ChkStartPressed_MultiFrame
	pop  bc
	
	dec  bc			; BC--
	ld   a, b
	or   a, c		; BC == 0?
	jr   nz, .loop	; If not, loop
	
.end:

	; Reset pal
	ld   a, $FF
	ldh  [rBGP], a
	ldh  [rOBP0], a
	ldh  [rOBP1], a
	
	call DisableSectLYC
	
	ld   d, TILE_INTRO_BLACK
	call ClearBGMapCustom
	
	; Reset scroll for char mode
	xor  a
	ldh  [hScrollX], a
	ldh  [hScrollY], a
	
	; Hide WINDOW
	ld   a, $90
	ldh  [rWY], a
	ld   a, $07
	ldh  [rWX], a
	
	; Disable LYC
	xor  a
	ldh  [rSTAT], a
	
	; Hide large sprite
	ld   hl, wOBJInfo2+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	ld   hl, wOBJInfo3+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	
	; Set new pal
	ld   a, $F0
	ldh  [rBGP], a
	ld   a, $8C
	ldh  [rOBP0], a
	ld   a, $4C
	ldh  [rOBP1], a
	
	; Loop the animations from the remainder of the modes (ISCC_KYO and above) 
	ld   a, $FF
	ld   [wIntroLoopOBJAnim], a
	
	; Next mode
	call Intro_CharS_SetNextChar
	ld   a, ISCC_KYO
	ld   [wIntroCharScene], a
	ld   a, ISC_CHAR
	ld   [wIntroScene], a
	xor  a
	ret
	
; IN
; - HL: Ptr to pixel position
; - BC: Amount to add
.addToPos:
	push hl ; Save coord ptr
		; HL = Coordinate
		ld   d, [hl]	; D = Pixels
		inc  hl
		ld   e, [hl]	; E = Subpixels
		push de			;
		pop  hl			; Move to HL
		
		; DE = HL + BC
		add  hl, bc		
		push hl
		pop  de
	pop  hl ; Restore coord ptr
	
	; Write back updated coord
	ld  [hl], d		; Write pixels
	inc  hl
	ld   [hl], e	; Write subpixels
	ret
	
; =============== IntroScene_IoriKyo ===============
; Iori and Kyo cutouts scroll towards the center of the screen.
; OUT
; - C flag: If set, end the intro
IntroScene_IoriKyo:
	
	;
	; Move "sections" at 15 frames at 15px/frame
	;
	ld   a, $0F	
.loop:
	push af
		ld   b, a	
		; Move Iori to the right
		ldh  a, [hScrollX]	; hScrollX -= A
		sub  a, b
		ldh  [hScrollX], a
		; Move Kyo to the left
		ldh  a, [rWX]		; rWX -= A
		sub  a, b
		ldh  [rWX], a
		
		; Wait 1 frame
		ld   a, $01
		call Intro_ChkStartPressed_MultiFrame
	pop  af
	dec  a			; Are we done?
	jr   nz, .loop	; If not, loop
	
	; Wait $78 frames
	ld   a, $78
	call Intro_ChkStartPressed_MultiFrame
	
	; End the intro 
	scf 		; Set C flag
	ret
	
; =============== Intro_CharS_MoveBG*_MultiFrame ===============
; Sets of subroutines to move the background across multiple frames.
; 
; IN
; - A: Number of frames *and* movement speed.
;      This value is used for both purposes, meaning the target
;      location grows exponentially.
;

; =============== Intro_CharS_MoveBGUp_MultiFrame ===============
; Moves the background up across multiple frames.
; IN
; - A: Number of frames *and* movement speed
Intro_CharS_MoveBGUp_MultiFrame:
	push af
		; Scroll screen down to move BG up
		ld   b, a
		ldh  a, [hScrollY]	; hScrollY += A
		add  b
		ldh  [hScrollY], a
		
		; Wait 1 frame
		ld   a, $01
		call Intro_CharS_WaitVBlank
	pop  af
	dec  a								; FramesLeft--
	jr   nz, Intro_CharS_MoveBGUp_MultiFrame	; No frames left? If not, loop
	ret
	
; =============== Intro_CharS_MoveBGDown_MultiFrame ===============
; Moves the background down across multiple frames.
; IN
; - A: Number of frames *and* movement speed
Intro_CharS_MoveBGDown_MultiFrame:
	push af
		; Scroll screen up to move BG down
		ld   b, a
		ldh  a, [hScrollY]	; hScrollY -= A
		sub  a, b
		ldh  [hScrollY], a
		
		; Wait 1 frame
		ld   a, $01
		call Intro_CharS_WaitVBlank
	pop  af
	dec  a									; FramesLeft--
	jr   nz, Intro_CharS_MoveBGDown_MultiFrame	; No frames left? If not, loop
	ret
	
; =============== Intro_CharS_MoveBGLeft_MultiFrame ===============
; Moves the background left across multiple frames.
; IN
; - A: Number of frames *and* movement speed
Intro_CharS_MoveBGLeft_MultiFrame:
	push af
		; Scroll screen right to move BG left
		ld   b, a
		ldh  a, [hScrollX]	; hScrollX += A
		add  b
		ldh  [hScrollX], a
		
		; Wait 1 frame
		ld   a, $01
		call Intro_CharS_WaitVBlank
	pop  af
	dec  a									; FramesLeft--
	jr   nz, Intro_CharS_MoveBGLeft_MultiFrame	; No frames left? If not, loop
	ret
	
; =============== Intro_CharS_MoveBGRight_MultiFrame ===============
; Moves the background right across multiple frames.
; IN
; - A: Number of frames *and* movement speed
Intro_CharS_MoveBGRight_MultiFrame:
	push af
		; Scroll screen left to move BG right
		ld   b, a
		ldh  a, [hScrollX] ; hScrollX -= A
		sub  a, b
		ldh  [hScrollX], a
		
		; Wait 1 frame
		ld   a, $01
		call Intro_CharS_WaitVBlank
	pop  af
	dec  a									; FramesLeft--
	jr   nz, Intro_CharS_MoveBGRight_MultiFrame	; No frames left? If not, loop
	ret
	
; =============== Intro_CharS_FillBGRect* ===============
; Set of functions that animate the tilemap to enlarge or shrink the white rectangles during the intro.
; These work by drawing a small rectangle to the tilemap and then moving the starting position.
; This is repeated for the specified amount of frames.
;
; Since the tilemap isn't cleared before drawing the rectangles, this allows the growing/shrinking
; effect to work, otherwise it would look like small rectangles moving.
; 
	
; =============== Intro_CharS_FillBGRectUp ===============
; Draws a rectangle that grows upwards every frame.
; IN
; - A: Number of frames
; IN (FillBGRect)
; - HL: Initial rect top left corner in tilemap
; - B: Rect Width
; - C: Rect Height
; - D: Tile ID to use
Intro_CharS_FillBGRectUp_MultiFrame:
	push af
	push bc
	push de
		push hl
			; Draw rectangle with current settings
			call FillBGRect
			
			; Wait 1 frame
			ld   a, $01
			call Intro_CharS_WaitVBlank
		pop  hl
		
		; Move origin up by 1 tile
		ld   de, -BG_TILECOUNT_H
		add  hl, de
	pop  de
	pop  bc
	pop  af
	
	dec  a											; Are we done?
	jr   nz, Intro_CharS_FillBGRectUp_MultiFrame	; If not, loop
	ret

; =============== Intro_CharS_FillBGRectDown_MultiFrame ===============
; Draws a rectangle that grows downwards every frame.
; IN
; - A: Number of frames
; IN (FillBGRect)
; - HL: Initial rect top left corner in tilemap
; - B: Rect Width
; - C: Rect Height
; - D: Tile ID to use
Intro_CharS_FillBGRectDown_MultiFrame:
	push af
	push bc
	push de
		push hl
			; Draw rectangle with current settings
			call FillBGRect
			
			; Wait 1 frame
			ld   a, $01
			call Intro_CharS_WaitVBlank
		pop  hl
		
		; Move origin down by 1 tile
		ld   de, BG_TILECOUNT_H
		add  hl, de
	pop  de
	pop  bc
	pop  af
	
	dec  a											; Are we done?
	jr   nz, Intro_CharS_FillBGRectDown_MultiFrame	; If not, loop
	ret
	
; =============== Intro_CharS_FillBGRectLeft_MultiFrame ===============
; Draws a rectangle that grows left every frame.
; IN
; - A: Number of frames
; IN (FillBGRect)
; - HL: Initial rect top left corner in tilemap
; - B: Rect Width
; - C: Rect Height
; - D: Tile ID to use
Intro_CharS_FillBGRectLeft_MultiFrame:
	push af
	push bc
	push de
		push hl
			; Draw rectangle with current settings
			call FillBGRect
			
			; Wait 1 frame
			ld   a, $01
			call Intro_CharS_WaitVBlank
		pop  hl
		
		; Move origin left by 1 tile
		dec  hl
	pop  de
	pop  bc
	pop  af
	
	dec  a											; Are we done?
	jr   nz, Intro_CharS_FillBGRectLeft_MultiFrame	; If not, loop
	ret
	
; =============== Intro_CharS_FillBGRectRight_MultiFrame ===============
; Draws a rectangle that grows right every frame.
; IN
; - A: Number of frames
; IN (FillBGRect)
; - HL: Initial rect top left corner in tilemap
; - B: Rect Width
; - C: Rect Height
; - D: Tile ID to use
Intro_CharS_FillBGRectRight_MultiFrame:
	push af
	push bc
	push de
		push hl
			; Draw rectangle with current settings
			call FillBGRect
			
			; Wait 1 frame
			ld   a, $01
			call Intro_CharS_WaitVBlank
		pop  hl
		
		; Move origin right by 1 tile
		inc  hl
	pop  de
	pop  bc
	pop  af
	
	dec  a	
	jr   nz, Intro_CharS_FillBGRectRight_MultiFrame	; If not, loop
	ret
	
; =============== Intro_CharS_CropOpenH_MultiFrame ===============
; Applies an horizontal crop opening transition to the tilemap.
;
; This is handled by drawing two white vertical strips, one at the left and one at the right.
; After the frame ends, the origin points are moved outwards.
;
; IN
; - A: Number of frames
; - HL: Left origin point
; - DE: Right origin point
; - C: Rect Height
Intro_CharS_CropOpenH_MultiFrame:
	push af
		push bc
			;#####
			push de
				push hl
					;------
					; Draw vertical strip on the left
					push bc
						push de
							ld   b, $01 				; B = Width
							ld   d, TILE_INTRO_WHITE
							call FillBGRect
						pop  de
					pop  bc
					
					; Draw vertical strip on the right		
					push de
					pop  hl						; HL = Right origin point
					ld   b, $01					; B = Width
					ld   d, TILE_INTRO_WHITE
					call FillBGRect
					
					; Wait 1 frame
					ld   a, $01
					call Intro_CharS_WaitVBlank
					;------
				pop  hl ; Restore left origin
			pop  de ; Restore right origin
			;#####
			
			; Move left origin point left by 1 tile
			dec  hl 
			; Move right origin point right by 1 tile
			inc  de
		pop  bc
	pop  af
	dec  a
	jr   nz, Intro_CharS_CropOpenH_MultiFrame
	ret
	
; =============== Intro_CharS_CropCloseH_MultiFrame ===============
; Applies a vertical crop closing transition to the tilemap.
;
; This is handled by drawing two black horizontal strips, one at the top and the other at the bottom.
; After the frame ends, the origin points are moved inwards.
;
; See also: Intro_CharS_CropOpenH_MultiFrame
;
; IN
; - A: Number of frames
; - HL: Top origin point
; - DE: Bottom origin point
Intro_CharS_CropCloseH_MultiFrame:
		push af
		push de
			push hl
				;------
				; Draw horizontal strip at the top
				push de
					ld   b, $15					; B = Width
					ld   c, $01					; C = Height
					ld   d, TILE_INTRO_BLACK	
					call FillBGRect
				pop  de
				
				; Draw horizontal strip at the bottom
				push de
				pop  hl							; HL = Bottom origin point
					ld   b, $15					; B = Width
					ld   c, $01					; C = Height
				ld   d, TILE_INTRO_BLACK
				call FillBGRect
				
				; Wait 4 frames
				ld   a, $04
				call Intro_CharS_WaitVBlank
				;------
			pop  hl ; Restore top origin 
		pop  de ; Restore bottom origin 
		
		; Move top origin point down by 1 tile
		ld   bc, BG_TILECOUNT_H			; HL += BG_TILECOUNT_H 
		add  hl, bc
		
		; Move bottom origin point up by 1 tile
		push hl
			ld   hl, -BG_TILECOUNT_H	; DE -= BG_TILECOUNT_H 
			add  hl, de
			push hl
			pop  de
		pop  hl
	pop  af
	dec  a
	jr   nz, Intro_CharS_CropCloseH_MultiFrame
	ret
	
; =============== Intro_CharS_WaitVBlank ===============
; Common code shared across character scenes.
Intro_CharS_WaitVBlank:
	; If wIntroLoopOBJAnim is set, use OBJLstS_DoAnimTiming_Loop as animation function,
	; otherwise use OBJLstS_DoAnimTiming_NoLoop. The two code paths are otherwise identical. 
	push af
		ld   a, [wIntroLoopOBJAnim]
		ld   b, a
		or   a				; wIntroLoopOBJAnim != 0?
		jr   nz, .useLoop	; If so, jump
.noLoop:
	pop  af
.delay1:
	push af
		; Animate Pl1 and Pl2 sprites
		ld   hl, wOBJInfo_Pl1+iOBJInfo_Status
		call OBJLstS_DoAnimTiming_NoLoop
		ld   hl, wOBJInfo_Pl2+iOBJInfo_Status
		call OBJLstS_DoAnimTiming_NoLoop
		; Apply H speed
		ld   de, wOBJInfo_Pl1+iOBJInfo_Status
		call OBJLstS_ApplyXSpeed
		ld   de, wOBJInfo_Pl2+iOBJInfo_Status
		call OBJLstS_ApplyXSpeed
		; Wait 1 frame
		ld   a, $01
		call Intro_ChkStartPressed_MultiFrame
	pop  af
	dec  a				; Waited all frames?
	jr   nz, .delay1	; If not, loop
	ret
	
.useLoop:
	pop  af
.delay2:
	push af
		; Animate Pl1 and Pl2 sprites
		ld   hl, wOBJInfo_Pl1+iOBJInfo_Status
		call OBJLstS_DoAnimTiming_Loop
		ld   hl, wOBJInfo_Pl2+iOBJInfo_Status
		call OBJLstS_DoAnimTiming_Loop
		; Apply H speed
		ld   de, wOBJInfo_Pl1+iOBJInfo_Status
		call OBJLstS_ApplyXSpeed
		ld   de, wOBJInfo_Pl2+iOBJInfo_Status
		call OBJLstS_ApplyXSpeed
		; Wait 1 frame
		ld   a, $01
		call Intro_ChkStartPressed_MultiFrame
	pop  af
	dec  a				; Waited all frames?
	jr   nz, .delay2	; If not, loop
	ret
	
; =============== Intro_CharS_LoadVRAM ===============
Intro_CharS_LoadVRAM:
	di
	;-----------------------------------
	rst  $10				; Stop LCD
	
	; Reset DMG Pal & vars
	ld   a, $FF
	ldh  [rBGP], a
	ldh  [rOBP0], a
	ldh  [rOBP1], a
	xor  a
	ld   [wIntroScene], a		; Not necessary
	ld   [wIntroCharScene], a
	ld   [wIntroLoopOBJAnim], a
	
	; Reset screen & coords
	call ClearBGMap
	call ClearWINDOWMap
	
	xor  a
	ldh  [hScrollX], a
	ldh  [hScrollY], a
	ld   [wOBJScrollX], a
	ld   [wOBJScrollY], a
	
	; Load GFX for scene
	ld   hl, GFXLZ_IntroBG
	ld   de, wLZSS_Buffer
	call DecompressLZSS
	ld   hl, wLZSS_Buffer
	ld   de, $9000			; full 3rd section	
	ld   b, $80
	call CopyTiles
	ld   hl, $C9CA
	ld   de, $8800			; 2nd section
	ld   b, $2A				
	call CopyTiles
	
	ld   hl, GFXLZ_Intro_IoriRiseOBJ
	ld   de, wLZSS_Buffer
	call DecompressLZSS
	ld   hl, wLZSS_Buffer
	ld   de, $8800+$0460	; lower part of 2nd section
	ld   b, $3A
	call CopyTiles
	
	; Fill BG black
	ld   hl, BGMap_Begin
	ld   b, $20
	ld   c, $20
	ld   d, $01
	call FillBGRect
	
	; Load default sprite mappings
	ld   hl, wOBJInfo_Pl1+iOBJInfo_Status
	ld   de, OBJInfoInit_Pl1
	call OBJLstS_InitFrom
	ld   hl, wOBJInfo_Pl2+iOBJInfo_Status
	ld   de, OBJInfoInit_Pl2
	call OBJLstS_InitFrom
	
	; Hide both sprites while the GFX are loading, and make them display
	; behind the background (for the window reveal effect to work).
	ld   hl, wOBJInfo_Pl1+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]					; Hide for now
	inc  hl									; Seek to iOBJInfo_OBJLstFlags
	set  SPRB_BGPRIORITY, [hl]				; Set BG priority
	ld   hl, wOBJInfo_Pl2+iOBJInfo_Status	; Do the same for Andy's sprite
	res  OSTB_VISIBLE, [hl]
	inc  hl
	set  SPRB_BGPRIORITY, [hl]
	
	; Initialize buffer info
	ld   hl, wOBJInfo_Pl1+iOBJInfo_Status
	call OBJLstS_DoAnimTiming_Initial
	ld   hl, wOBJInfo_Pl2+iOBJInfo_Status
	call OBJLstS_DoAnimTiming_Initial
	
	; Hide WINDOW
	ld   a, $90
	ldh  [rWY], a
	ld   a, $07
	ldh  [rWX], a
	
	ld   a, LCDC_PRIORITY|LCDC_OBJENABLE|LCDC_OBJSIZE|LCDC_WENABLE|LCDC_WTILEMAP|LCDC_ENABLE
	rst  $18				; Resume LCD
	;-----------------------------------
	ei
	
	; Delay $14 frames.
	ld   a, $14
	call Intro_ChkStartPressed_MultiFrame
	
	ld   a, $8C		; 1P Pal
	ldh  [rOBP0], a
	ld   a, $4C		; 2P Pal
	ldh  [rOBP1], a
	ld   a, $C0		; BG
	ldh  [rBGP], a
	ret
	
; =============== Intro_IoriRise_LoadVRAM ===============
; Sets up the scene for Iori rising from below.
Intro_IoriRise_LoadVRAM:
	di
	;-----------------------------------
	rst  $10				; Stop LCD
	
	; The scene uses the sector system to display the black borders thanks to the WINDOW layer.
	
	; Set the middle section start/end, where the WINDOW is disabled and sprites are visible.
	ld   a, $1E			; Disable at this scanline
	ld   b, $6F			; Enable again here
	call SetSectLYC
	
	; Reset DMG Pal & vars
	xor  $FF
	ldh  [rBGP], a
	ldh  [rOBP0], a
	ldh  [rOBP1], a
	xor  a
	ld   [wIntroScene], a
	
	; Clear BG layer
	call ClearBGMap
	; Color WINDOW black to hide sprites
	ld   d, TILE_INTRO_BLACK
	call ClearWINDOWMapCustom
	
	; Reset coords
	xor  a
	ldh  [hScrollY], a
	ld   [wOBJScrollX], a
	ld   [wOBJScrollY], a
	
	;
	; Display "Sun" at the center of the tilemap
	;
	
	; Set BG scrolling to partially hide it behind the WINDOW.
	; As frames pass it will become progressively more visible.
	ld   a, $F0
	ldh  [hScrollX], a
	ld   a, $E0
	ldh  [hScrollY], a
	
	; Decompress Sun tilemap to a rectangle area
	ld   hl, BGLZ_Intro_Sun
	ld   de, wLZSS_Buffer
	call DecompressLZSS
	ld   de, wLZSS_Buffer
	ld   hl, BGMap_Begin
	ld   b, $10			; Width
	ld   c, $06			; Height
	call CopyBGToRect
	
	; Really disable the player sprites, to be sure I guess
	ld   hl, wOBJInfo_Pl1+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	ld   hl, wOBJInfo_Pl2+iOBJInfo_Status
	res  OSTB_VISIBLE, [hl]
	
	; Write Iori's sprites to the special slots.
	; This Iori is big enough that two sprites are needed to display him.
	ld   hl, wOBJInfo2+iOBJInfo_Status
	ld   de, OBJInfoInit_Intro_Iori
	call OBJLstS_InitFrom
	ld   hl, wOBJInfo3+iOBJInfo_Status
	ld   de, OBJInfoInit_Intro_Iori
	call OBJLstS_InitFrom
	
	; ???
	ld   a, $04
	ld   [wOBJInfo3+iOBJInfo_OBJLstPtrTblOffset], a
	
	; Display the WINDOW
	ld   a, $00
	ldh  [rWY], a
	ld   a, $07
	ldh  [rWX], a
	ld   a, LCDC_PRIORITY|LCDC_OBJENABLE|LCDC_OBJSIZE|LCDC_WENABLE|LCDC_WTILEMAP|LCDC_ENABLE
	rst  $18				; Resume LCD
	;-----------------------------------
	
	; Enable scanline (and VBlank, for some reason) interrupts
	ldh  a, [rSTAT]
	or   a, STAT_LYC
	ldh  [rSTAT], a
	ldh  a, [rIE]
	or   a, I_STAT|I_VBLANK
	ldh  [rIE], a
	
	ei
	
	; Wait 2 frames while the sprite graphics load
	call Task_PassControl_NoDelay
	call Task_PassControl_NoDelay
	
	; Only after that set the proper palettes to make things visible
	ld   a, $8C					; OBJ palettes
	ldh  [rOBP0], a
	ld   a, $00
	ldh  [rOBP1], a
	ld   a, $1B					; Standard colors for the BG
	ldh  [hScreenSect1BGP], a
	ld   a, $FF					; Completely black borders
	ldh  [hScreenSect0BGP], a
	ldh  [hScreenSect2BGP], a
	ret
	
; =============== Intro_IoriKyo_LoadVRAM ===============
; Sets up the scene for Iori and Kyo cutouts moving into view.
Intro_IoriKyo_LoadVRAM:
	di
	;-----------------------------------
	rst  $10				; Stop LCD
	
	; Reset DMG Pal & vars
	xor  a
	ldh  [rBGP], a
	ldh  [rOBP0], a
	ldh  [rOBP1], a
	ld   [wIntroScene], a
	
	; Reset screen & coords
	call ClearBGMap
	call ClearWINDOWMap
	
	xor  a
	ldh  [hScrollY], a
	ld   [wOBJScrollX], a
	ld   [wOBJScrollY], a
	
	; 
	ld   a, $60
	ldh  [hScrollX], a
	
	; Notes:
	; - Due to the palettes used, Black and White are inverted in this scene.
	; - This scene does not use the section system.
	;   Instead, Kyo is in the WINDOW layer and gets scrolled independently.
	
	; Create white horizontal bar for Iori for upper section
	ld   hl, $9820
	ld   b, $20
	ld   c, $07
	ld   d, TILE_INTRO_BLACK
	call FillBGRect
	
	; Create white horizontal bar for Kyo in the lower section
	ld   hl, $9920
	ld   b, $20
	ld   c, $08
	ld   d, TILE_INTRO_BLACK
	call FillBGRect
	
	; Create white backdrop for the section used to display Kyo
	ld   hl, WINDOWMap_Begin
	ld   b, $14
	ld   c, $08
	ld   d, $01
	call FillBGRect
	
	; Draw Iori tilemap on the left side of the upper section.
	; Written to the BG layer.
	ld   hl, BGLZ_Intro_IoriCutout
	ld   de, wLZSS_Buffer
	call DecompressLZSS
	ld   de, wLZSS_Buffer
	ld   hl, $9820
	ld   b, $0E
	ld   c, $07
	call CopyBGToRect
	
	; Draw Kyo tilemap on the right side of the lower section
	; Written to the top of the WINDOW, which will be moved down
	ld   hl, BGLZ_Intro_KyoCutout
	ld   de, wLZSS_Buffer
	call DecompressLZSS
	ld   de, wLZSS_Buffer
	ld   hl, WINDOWMap_Begin
	ld   b, $0E
	ld   c, $08
	call CopyBGToRect
	
	; Remove all sprites
	call ClearOBJInfo
	
	; Align WINDOW with lower horizontal bar, off-screen on the right
	ld   a, $90
	ld   a, $48
	ldh  [rWY], a
	ld   a, $A3
	ldh  [rWX], a
	
	ld   a, LCDC_PRIORITY|LCDC_OBJENABLE|LCDC_OBJSIZE|LCDC_WENABLE|LCDC_WTILEMAP|LCDC_ENABLE
	rst  $18				; Resume LCD
	;-----------------------------------
	ei
	call Task_PassControl_NoDelay
	call Task_PassControl_NoDelay
	
	; Set palettes
	ld   a, $18
	ldh  [rOBP0], a
	ld   a, $00
	ldh  [rOBP1], a
	ld   a, $1B
	ldh  [rBGP], a
	ret
	
; =============== Intro_ChkStartPressed_MultiFrame ===============
; Checks if the START button is pressed for the specified amount of frames.
; While this happens the task is essentially paused.
; IN
; - A: Frames to check
Intro_ChkStartPressed_MultiFrame:
	push af
		call Intro_Base_IsStartPressed			; Pressed START?
		jp   c, Intro_End						; If so, end the intro
		call Task_PassControl_NoDelay
	pop  af
	dec  a										; Waited all frames?
	jp   nz, Intro_ChkStartPressed_MultiFrame	; If not, loop
	ret
	
; =============== Intro_Base_IsStartPressed ===============
; Checks if START is pressed on any controller.
; OUT
; - C flag: If set, START is pressed on any controller.
Intro_Base_IsStartPressed:
	ldh  a, [hJoyNewKeys]
	bit  KEYB_START, a		; Pressed START on controller 1?
	jp   nz, .pressed		; If so, jump
	ldh  a, [hJoyNewKeys2]
	bit  KEYB_START, a		; Pressed START on controller 1?
	jp   nz, .pressed		; If so, jump
.not:
	xor  a	; clear C flag
	ret
.pressed:
	scf		; set C flag
	ret
	
IntroTextPtrTable:
	db $04				; Number of strings to print
	dw TextDef_Intro0
	dw TextDef_Intro1
	dw TextDef_Intro2
	dw TextDef_Intro3
TextDef_Intro0: 
	dw $9900	; Tilemap ptr
.c:	db $24		; String length
.s:	db " VIOLENT FIGHTING",C_NL,C_NL,"  TO COME AGAIN!",C_NL
TextDef_Intro1: 
	dw $98E0
.c:	db $2E
.s: db " AS A YEAR FLEW-BY",C_NL,C_NL,"  FROM",C_NL,C_NL,"  THE EXCITEMENT,",C_NL
TextDef_Intro2: 
	dw $98C0
.c:	db $45
.s: db " WE NOW DECLARE THE",C_NL,C_NL,"  OPENING OF OUR",C_NL,C_NL,"  SPECIAL TEAM",C_NL,C_NL,"  TOURNAMENT",C_NL,C_NL
TextDef_Intro3: 
	dw $9920
.c:	db $14
.s: db "       AGAIN....",C_NL,C_NL,C_NL,C_NL

OBJInfoInit_Intro_Iori:
	db OST_VISIBLE ; iOBJInfo_Status
	db $80 ; iOBJInfo_OBJLstFlags
	db $00 ; iOBJInfo_OBJLstFlagsView
	db $18 ; iOBJInfo_X
	db $00 ; iOBJInfo_XSub
	db $50 ; iOBJInfo_Y
	db $00 ; iOBJInfo_YSub
	db $00 ; iOBJInfo_SpeedX
	db $00 ; iOBJInfo_SpeedXSub
	db $00 ; iOBJInfo_SpeedY
	db $00 ; iOBJInfo_SpeedYSub
	db $00 ; iOBJInfo_RelX (auto)
	db $00 ; iOBJInfo_RelY (auto)
	db $C6 ; iOBJInfo_TileIDBase
	db LOW($8000) ; iOBJInfo_VRAMPtr_Low
	db HIGH($8000) ; iOBJInfo_VRAMPtr_High
	db BANK(OBJLstPtrTable_Intro_Iori) ; iOBJInfo_BankNum (BANK $1C)
	db LOW(OBJLstPtrTable_Intro_Iori) ; iOBJInfo_OBJLstPtrTbl_Low
	db HIGH(OBJLstPtrTable_Intro_Iori) ; iOBJInfo_OBJLstPtrTbl_High
	db $00 ; iOBJInfo_OBJLstPtrTblOffset
	db $00 ; iOBJInfo_BankNumView
	db LOW(OBJLstPtrTable_Intro_Iori) ; iOBJInfo_OBJLstPtrTbl_LowView
	db HIGH(OBJLstPtrTable_Intro_Iori) ; iOBJInfo_OBJLstPtrTbl_HighView
	db $00 ; iOBJInfo_OBJLstPtrTblOffset
	db $00 ; iOBJInfo_ColiBoxId (auto)
	db $00 ; iOBJInfo_HitboxId (auto)
	db $00 ; iOBJInfo_ForceHitboxId
	db $02 ; iOBJInfo_FrameLeft
	db $02 ; iOBJInfo_FrameTotal
	db LOW(wGFXBufInfo_Pl1) ; iOBJInfo_BufInfoPtr_Low
	db HIGH(wGFXBufInfo_Pl1) ; iOBJInfo_BufInfoPtr_High

OBJLstPtrTable_Intro_Iori:
	dw OBJLstHdrA_Intro_Iori0, $FFFF
	dw OBJLstHdrA_Intro_Iori1, $FFFF
	dw $FFFF
		
OBJLstHdrA_Intro_Iori0:
	db OLF_NOBUF ; iOBJLstHdrA_Flags
	db $00 ; iOBJLstHdrA_ColiBoxId
	db $00 ; iOBJLstHdrA_HitBoxId
	db $FF,$FF,$FF ; iOBJLstHdrA_GFXPtr + iOBJLstHdrA_GFXBank
	dw .bin ; iOBJLstHdrA_DataPtr
	db $00 ; iOBJLstHdrA_XOffset
	db $00 ; iOBJLstHdrA_YOffset
.bin:
	db $11 ; OBJ Count
	;    Y   X  ID+FLAG
	db $40,$21,$18 ; $00
	db $40,$29,$1A ; $01
	db $40,$31,$1C ; $02
	db $40,$39,$1E ; $03
	db $40,$41,$20 ; $04
	db $40,$49,$22 ; $05
	db $30,$29,$24 ; $06
	db $30,$31,$26 ; $07
	db $30,$39,$28 ; $08
	db $30,$41,$2A ; $09
	db $30,$49,$2C ; $0A
	db $20,$29,$2E ; $0B
	db $20,$31,$30 ; $0C
	db $20,$39,$32 ; $0D
	db $20,$41,$34 ; $0E
	db $20,$49,$36 ; $0F
	db $35,$51,$38 ; $10
		
OBJLstHdrA_Intro_Iori1:
	db OLF_NOBUF ; iOBJLstHdrA_Flags
	db $00 ; iOBJLstHdrA_ColiBoxId
	db $00 ; iOBJLstHdrA_HitBoxId
	db $FF,$FF,$FF ; iOBJLstHdrA_GFXPtr + iOBJLstHdrA_GFXBank
	dw .bin ; iOBJLstHdrA_DataPtr
	db $00 ; iOBJLstHdrA_XOffset
	db $00 ; iOBJLstHdrA_YOffset
.bin:
	db $0C ; OBJ Count
	;    Y   X  ID+FLAG
	db $60,$21,$00 ; $00
	db $60,$29,$02 ; $01
	db $60,$31,$04 ; $02
	db $60,$39,$06 ; $03
	db $60,$41,$08 ; $04
	db $60,$49,$0A ; $05
	db $50,$21,$0C ; $06
	db $50,$29,$0E ; $07
	db $50,$31,$10 ; $08
	db $50,$39,$12 ; $09
	db $50,$41,$14 ; $0A
	db $50,$49,$16 ; $0B
	
GFXLZ_IntroBG: INCBIN "data/gfx/intro_bg.lzc"
BGLZ_Intro_IoriCutout: INCBIN "data/bg/intro_ioricutout.lzs"
BGLZ_Intro_KyoCutout: INCBIN "data/bg/intro_kyocutout.lzs"
BGLZ_Intro_Sun: INCBIN "data/bg/intro_sun.lzs"
GFXLZ_Intro_IoriRiseOBJ: INCBIN "data/gfx/intro_ioririse_obj.lzc"
L1C7519: db $00;X
L1C751A: db $2B
L1C751B: db $C5
L1C751C: db $AF
L1C751D: db $C3
L1C751E: db $C8
L1C751F: db $B4
L1C7520: db $21
L1C7521: db $FF
L1C7522: db $FF
L1C7523: db $B5
L1C7524: db $DA
L1C7525: db $C4
L1C7526: db $CC
L1C7527: db $DE
L1C7528: db $C2
L1C7529: db $B6
L1C752A: db $AF
L1C752B: db $C3
L1C752C: db $BF
L1C752D: db $C9
L1C752E: db $C3
L1C752F: db $B2
L1C7530: db $C4
L1C7531: db $DE
L1C7532: db $C3
L1C7533: db $DE
L1C7534: db $FF
L1C7535: db $FF
L1C7536: db $BD
L1C7537: db $DD
L1C7538: db $C0
L1C7539: db $DE
L1C753A: db $C9
L1C753B: db $CA
L1C753C: db $B7
L1C753D: db $BE
L1C753E: db $B7
L1C753F: db $C3
L1C7540: db $B7
L1C7541: db $C0
L1C7542: db $DE
L1C7543: db $C5
L1C7544: db $A1
L1C7545: db $FF
L1C7546: db $2A
L1C7547: db $DC
L1C7548: db $BB
L1C7549: db $DE
L1C754A: db $CA
L1C754B: db $BF
L1C754C: db $DA
L1C754D: db $CE
L1C754E: db $C4
L1C754F: db $DE
L1C7550: db $FF
L1C7551: db $FF
L1C7552: db $BC
L1C7553: db $DE
L1C7554: db $AD
L1C7555: db $B3
L1C7556: db $D6
L1C7557: db $B3
L1C7558: db $C3
L1C7559: db $DE
L1C755A: db $CA
L1C755B: db $C5
L1C755C: db $B2
L1C755D: db $21
L1C755E: db $FF
L1C755F: db $FF
L1C7560: db $BD
L1C7561: db $CD
L1C7562: db $DE
L1C7563: db $C3
L1C7564: db $CA
L1C7565: db $BA
L1C7566: db $BA
L1C7567: db $DB
L1C7568: db $C9
L1C7569: db $D3
L1C756A: db $C1
L1C756B: db $D6
L1C756C: db $B3
L1C756D: db $C0
L1C756E: db $DE
L1C756F: db $21
L1C7570: db $FF
L1C7571: db $28
L1C7572: db $B5
L1C7573: db $DA
L1C7574: db $C9
L1C7575: db $C5
L1C7576: db $B6
L1C7577: db $C6
L1C7578: db $B2
L1C7579: db $D9
L1C757A: db $B5
L1C757B: db $B5
L1C757C: db $B6
L1C757D: db $D0
L1C757E: db $A6
L1C757F: db $FF
L1C7580: db $FF
L1C7581: db $B5
L1C7582: db $BA
L1C7583: db $BC
L1C7584: db $C1
L1C7585: db $CF
L1C7586: db $AF
L1C7587: db $C0
L1C7588: db $D6
L1C7589: db $B3
L1C758A: db $C0
L1C758B: db $DE
L1C758C: db $C5
L1C758D: db $A1
L1C758E: db $FF
L1C758F: db $FF
L1C7590: db $DC
L1C7591: db $D9
L1C7592: db $B8
L1C7593: db $B5
L1C7594: db $D3
L1C7595: db $B3
L1C7596: db $C5
L1C7597: db $D6
L1C7598: db $21
L1C7599: db $FF
L1C759A: db $20
L1C759B: db $CB
L1C759C: db $C2
L1C759D: db $D6
L1C759E: db $B3
L1C759F: db $C5
L1C75A0: db $C9
L1C75A1: db $CA
L1C75A2: db $B6
L1C75A3: db $B8
L1C75A4: db $BA
L1C75A5: db $DE
L1C75A6: db $21
L1C75A7: db $FF
L1C75A8: db $FF
L1C75A9: db $BF
L1C75AA: db $C9
L1C75AB: db $B2
L1C75AC: db $BC
L1C75AD: db $BB
L1C75AE: db $B4
L1C75AF: db $B1
L1C75B0: db $DA
L1C75B1: db $CA
L1C75B2: db $DE
L1C75B3: db $CF
L1C75B4: db $B9
L1C75B5: db $CA
L1C75B6: db $BC
L1C75B7: db $C5
L1C75B8: db $B2
L1C75B9: db $21
L1C75BA: db $FF
L1C75BB: db $38
L1C75BC: db $B7
L1C75BD: db $AE
L1C75BE: db $B8
L1C75BF: db $B9
L1C75C0: db $DE
L1C75C1: db $DD
L1C75C2: db $D8
L1C75C3: db $AD
L1C75C4: db $B3
L1C75C5: db $CA
L1C75C6: db $B7
L1C75C7: db $AE
L1C75C8: db $B8
L1C75C9: db $B9
L1C75CA: db $DE
L1C75CB: db $DD
L1C75CC: db $C6
L1C75CD: db $FF
L1C75CE: db $FF
L1C75CF: db $B5
L1C75D0: db $B2
L1C75D1: db $C3
L1C75D2: db $C9
L1C75D3: db $D0
L1C75D4: db $CA
L1C75D5: db $AF
L1C75D6: db $BD
L1C75D7: db $D9
L1C75D8: db $C1
L1C75D9: db $B6
L1C75DA: db $D7
L1C75DB: db $C9
L1C75DC: db $B9
L1C75DD: db $DE
L1C75DE: db $B2
L1C75DF: db $FF
L1C75E0: db $FF
L1C75E1: db $BC
L1C75E2: db $DE
L1C75E3: db $AD
L1C75E4: db $C2
L1C75E5: db $C0
L1C75E6: db $DE
L1C75E7: db $21
L1C75E8: db $D4
L1C75E9: db $BD
L1C75EA: db $D4
L1C75EB: db $BD
L1C75EC: db $C4
L1C75ED: db $B5
L1C75EE: db $C1
L1C75EF: db $CA
L1C75F0: db $BC
L1C75F1: db $C5
L1C75F2: db $B2
L1C75F3: db $FF
L1C75F4: db $2A
L1C75F5: db $C4
L1C75F6: db $DE
L1C75F7: db $C5
L1C75F8: db $B2
L1C75F9: db $BC
L1C75FA: db $C0
L1C75FB: db $3F
L1C75FC: db $FF
L1C75FD: db $FF
L1C75FE: db $B6
L1C75FF: db $B5
L1C7600: db $B6
L1C7601: db $DE
L1C7602: db $D5
L1C7603: db $D2
L1C7604: db $B3
L1C7605: db $C2
L1C7606: db $C2
L1C7607: db $AF
L1C7608: db $C1
L1C7609: db $AD
L1C760A: db $B3
L1C760B: db $B6
L1C760C: db $DD
L1C760D: db $BC
L1C760E: db $DE
L1C760F: db $FF
L1C7610: db $FF
L1C7611: db $D4
L1C7612: db $C3
L1C7613: db $DE
L1C7614: db $A1
L1C7615: db $20
L1C7616: db $BC
L1C7617: db $AC
L1C7618: db $B7
L1C7619: db $AF
L1C761A: db $C4
L1C761B: db $BE
L1C761C: db $C5
L1C761D: db $21
L1C761E: db $FF
L1C761F: db $25
L1C7620: db $C2
L1C7621: db $B7
L1C7622: db $DE
L1C7623: db $B6
L1C7624: db $DE
L1C7625: db $B1
L1C7626: db $AF
L1C7627: db $C0
L1C7628: db $C5
L1C7629: db $D7
L1C762A: db $CF
L1C762B: db $C0
L1C762C: db $C0
L1C762D: db $C0
L1C762E: db $B6
L1C762F: db $B2
L1C7630: db $FF
L1C7631: db $FF
L1C7632: db $CF
L1C7633: db $BC
L1C7634: db $AE
L1C7635: db $B3
L1C7636: db $A1
L1C7637: db $FF
L1C7638: db $FF
L1C7639: db $C0
L1C763A: db $C9
L1C763B: db $BC
L1C763C: db $D0
L1C763D: db $C6
L1C763E: db $CF
L1C763F: db $AF
L1C7640: db $C3
L1C7641: db $CF
L1C7642: db $BD
L1C7643: db $21
L1C7644: db $FF
L1C7645: db $36
L1C7646: db $CF
L1C7647: db $B1
L1C7648: db $A4
L1C7649: db $CE
L1C764A: db $DD
L1C764B: db $B7
L1C764C: db $A6
L1C764D: db $C1
L1C764E: db $AE
L1C764F: db $AF
L1C7650: db $C4
L1C7651: db $C0
L1C7652: db $DE
L1C7653: db $BE
L1C7654: db $CA
L1C7655: db $DE
L1C7656: db $FF
L1C7657: db $FF
L1C7658: db $B6
L1C7659: db $D9
L1C765A: db $B2
L1C765B: db $B6
L1C765C: db $D9
L1C765D: db $B2
L1C765E: db $21
L1C765F: db $20
L1C7660: db $BC
L1C7661: db $D7
L1C7662: db $C7
L1C7663: db $B2
L1C7664: db $D8
L1C7665: db $AD
L1C7666: db $B3
L1C7667: db $FF
L1C7668: db $FF
L1C7669: db $C6
L1C766A: db $DD
L1C766B: db $BC
L1C766C: db $DE
L1C766D: db $AD
L1C766E: db $C2
L1C766F: db $A4
L1C7670: db $BB
L1C7671: db $B2
L1C7672: db $B7
L1C7673: db $AE
L1C7674: db $B3
L1C7675: db $AF
L1C7676: db $C3
L1C7677: db $C4
L1C7678: db $BA
L1C7679: db $C8
L1C767A: db $21
L1C767B: db $FF
L1C767C: db $1E
L1C767D: db $B1
L1C767E: db $C5
L1C767F: db $C0
L1C7680: db $CA
L1C7681: db $BC
L1C7682: db $C5
L1C7683: db $C5
L1C7684: db $B2
L1C7685: db $DC
L1C7686: db $A1
L1C7687: db $FF
L1C7688: db $FF
L1C7689: db $BA
L1C768A: db $BA
L1C768B: db $CA
L1C768C: db $BE
L1C768D: db $DD
L1C768E: db $BC
L1C768F: db $DE
L1C7690: db $AE
L1C7691: db $B3
L1C7692: db $BC
L1C7693: db $DE
L1C7694: db $AC
L1C7695: db $C5
L1C7696: db $B2
L1C7697: db $D3
L1C7698: db $C9
L1C7699: db $A1
L1C769A: db $FF
L1C769B: db $30
L1C769C: db $B1
L1C769D: db $AF
L1C769E: db $C4
L1C769F: db $B3
L1C76A0: db $C3
L1C76A1: db $B7
L1C76A2: db $C5
L1C76A3: db $C1
L1C76A4: db $B6
L1C76A5: db $D7
L1C76A6: db $C6
L1C76A7: db $BC
L1C76A8: db $CA
L1C76A9: db $B2
L1C76AA: db $BB
L1C76AB: db $DA
L1C76AC: db $D9
L1C76AD: db $FF
L1C76AE: db $FF
L1C76AF: db $C9
L1C76B0: db $CA
L1C76B1: db $A4
L1C76B2: db $C4
L1C76B3: db $DE
L1C76B4: db $DD
L1C76B5: db $C5
L1C76B6: db $B7
L1C76B7: db $D3
L1C76B8: db $C1
L1C76B9: db $C0
L1C76BA: db $DE
L1C76BB: db $21
L1C76BC: db $FF
L1C76BD: db $FF
L1C76BE: db $BB
L1C76BF: db $B1
L1C76C0: db $21
L1C76C1: db $20
L1C76C2: db $B5
L1C76C3: db $BF
L1C76C4: db $DA
L1C76C5: db $D9
L1C76C6: db $B6
L1C76C7: db $DE
L1C76C8: db $B2
L1C76C9: db $B2
L1C76CA: db $21
L1C76CB: db $FF
L1C76CC: db $33
L1C76CD: db $DC
L1C76CE: db $C0
L1C76CF: db $BC
L1C76D0: db $A6
L1C76D1: db $C0
L1C76D2: db $B5
L1C76D3: db $BE
L1C76D4: db $D9
L1C76D5: db $C5
L1C76D6: db $D7
L1C76D7: db $BE
L1C76D8: db $B6
L1C76D9: db $B2
L1C76DA: db $BB
L1C76DB: db $B2
L1C76DC: db $B7
L1C76DD: db $AE
L1C76DE: db $B3
L1C76DF: db $FF
L1C76E0: db $FF
L1C76E1: db $CA
L1C76E2: db $CF
L1C76E3: db $C1
L1C76E4: db $B6
L1C76E5: db $DE
L1C76E6: db $B2
L1C76E7: db $C5
L1C76E8: db $B2
L1C76E9: db $C0
L1C76EA: db $DE
L1C76EB: db $DB
L1C76EC: db $B3
L1C76ED: db $21
L1C76EE: db $FF
L1C76EF: db $FF
L1C76F0: db $B6
L1C76F1: db $C3
L1C76F2: db $DA
L1C76F3: db $CA
L1C76F4: db $DE
L1C76F5: db $C9
L1C76F6: db $CA
L1C76F7: db $C5
L1C76F8: db $BC
L1C76F9: db $C0
L1C76FA: db $DE
L1C76FB: db $B6
L1C76FC: db $DE
L1C76FD: db $C5
L1C76FE: db $21
L1C76FF: db $FF
L1C7700: db $26
L1C7701: db $6C
L1C7702: db $B0
L1C7703: db $6F
L1C7704: db $B0
L1C7705: db $C6
L1C7706: db $C3
L1C7707: db $DE
L1C7708: db $D3
L1C7709: db $A4
L1C770A: db $C5
L1C770B: db $AF
L1C770C: db $C0
L1C770D: db $C2
L1C770E: db $D3
L1C770F: db $D8
L1C7710: db $B6
L1C7711: db $21
L1C7712: db $FF
L1C7713: db $FF
L1C7714: db $B5
L1C7715: db $B6
L1C7716: db $BC
L1C7717: db $B8
L1C7718: db $C3
L1C7719: db $C5
L1C771A: db $D0
L1C771B: db $C0
L1C771C: db $DE
L1C771D: db $B6
L1C771E: db $DE
L1C771F: db $C4
L1C7720: db $CF
L1C7721: db $D7
L1C7722: db $DD
L1C7723: db $BF
L1C7724: db $DE
L1C7725: db $21
L1C7726: db $FF
L1C7727: db $2E
L1C7728: db $CA
L1C7729: db $DE
L1C772A: db $B6
L1C772B: db $C6
L1C772C: db $C2
L1C772D: db $B9
L1C772E: db $D9
L1C772F: db $B8
L1C7730: db $BD
L1C7731: db $D8
L1C7732: db $CA
L1C7733: db $C5
L1C7734: db $B2
L1C7735: db $C4
L1C7736: db $B2
L1C7737: db $B3
L1C7738: db $B6
L1C7739: db $DE
L1C773A: db $FF
L1C773B: db $FF
L1C773C: db $CF
L1C773D: db $D9
L1C773E: db $C3
L1C773F: db $DE
L1C7740: db $B5
L1C7741: db $CF
L1C7742: db $B4
L1C7743: db $C0
L1C7744: db $C1
L1C7745: db $C9
L1C7746: db $BA
L1C7747: db $C4
L1C7748: db $A6
L1C7749: db $FF
L1C774A: db $FF
L1C774B: db $B2
L1C774C: db $AF
L1C774D: db $C3
L1C774E: db $B2
L1C774F: db $D9
L1C7750: db $D6
L1C7751: db $B3
L1C7752: db $C0
L1C7753: db $DE
L1C7754: db $21
L1C7755: db $FF
L1C7756: db $2F
L1C7757: db $B1
L1C7758: db $C5
L1C7759: db $C0
L1C775A: db $C0
L1C775B: db $C1
L1C775C: db $D3
L1C775D: db $D5
L1C775E: db $D2
L1C775F: db $A6
L1C7760: db $D0
L1C7761: db $D9
L1C7762: db $C3
L1C7763: db $DE
L1C7764: db $BC
L1C7765: db $AE
L1C7766: db $A1
L1C7767: db $FF
L1C7768: db $FF
L1C7769: db $BB
L1C776A: db $B1
L1C776B: db $B4
L1C776C: db $B2
L1C776D: db $B4
L1C776E: db $DD
L1C776F: db $C9
L1C7770: db $D5
L1C7771: db $D2
L1C7772: db $C9
L1C7773: db $BE
L1C7774: db $B6
L1C7775: db $B2
L1C7776: db $C6
L1C7777: db $B1
L1C7778: db $DD
L1C7779: db $C5
L1C777A: db $B2
L1C777B: db $FF
L1C777C: db $FF
L1C777D: db $BC
L1C777E: db $C3
L1C777F: db $B1
L1C7780: db $B9
L1C7781: db $DE
L1C7782: db $D9
L1C7783: db $DC
L1C7784: db $21
L1C7785: db $FF
L1C7786: db $30
L1C7787: db $B1
L1C7788: db $C5
L1C7789: db $C0
L1C778A: db $C0
L1C778B: db $C1
L1C778C: db $CA
L1C778D: db $CE
L1C778E: db $DD
L1C778F: db $C4
L1C7790: db $B3
L1C7791: db $C9
L1C7792: db $C1
L1C7793: db $B6
L1C7794: db $D7
L1C7795: db $B6
L1C7796: db $DE
L1C7797: db $FF
L1C7798: db $FF
L1C7799: db $C5
L1C779A: db $C6
L1C779B: db $B6
L1C779C: db $A6
L1C779D: db $BC
L1C779E: db $D7
L1C779F: db $C5
L1C77A0: db $B2
L1C77A1: db $D6
L1C77A2: db $B3
L1C77A3: db $C8
L1C77A4: db $A1
L1C77A5: db $FF
L1C77A6: db $FF
L1C77A7: db $BF
L1C77A8: db $DA
L1C77A9: db $C3
L1C77AA: db $DE
L1C77AB: db $CA
L1C77AC: db $DC
L1C77AD: db $C0
L1C77AE: db $BC
L1C77AF: db $CA
L1C77B0: db $C0
L1C77B1: db $B5
L1C77B2: db $BE
L1C77B3: db $C5
L1C77B4: db $B2
L1C77B5: db $A1
L1C77B6: db $FF
L1C77B7: db $32
L1C77B8: db $BE
L1C77B9: db $B6
L1C77BA: db $B2
L1C77BB: db $B6
L1C77BC: db $DE
L1C77BD: db $BF
L1C77BE: db $DE
L1C77BF: db $B3
L1C77C0: db $B5
L1C77C1: db $C9
L1C77C2: db $C5
L1C77C3: db $B6
L1C77C4: db $C3
L1C77C5: db $DE
L1C77C6: db $D3
L1C77C7: db $B4
L1C77C8: db $C3
L1C77C9: db $B2
L1C77CA: db $FF
L1C77CB: db $FF
L1C77CC: db $CF
L1C77CD: db $BD
L1C77CE: db $A1
L1C77CF: db $20
L1C77D0: db $BC
L1C77D1: db $DD
L1C77D2: db $C9
L1C77D3: db $BA
L1C77D4: db $DD
L1C77D5: db $C4
L1C77D6: db $DD
L1C77D7: db $CA
L1C77D8: db $B5
L1C77D9: db $BB
L1C77DA: db $D2
L1C77DB: db $D9
L1C77DC: db $FF
L1C77DD: db $FF
L1C77DE: db $BA
L1C77DF: db $C4
L1C77E0: db $CA
L1C77E1: db $CC
L1C77E2: db $B6
L1C77E3: db $C9
L1C77E4: db $B3
L1C77E5: db $C3
L1C77E6: db $DE
L1C77E7: db $BD
L1C77E8: db $A1
L1C77E9: db $FF
L1C77EA: db $24
L1C77EB: db $C5
L1C77EC: db $DD
L1C77ED: db $C4
L1C77EE: db $DE
L1C77EF: db $C3
L1C77F0: db $DE
L1C77F1: db $D3
L1C77F2: db $B2
L1C77F3: db $B5
L1C77F4: db $B3
L1C77F5: db $21
L1C77F6: db $FF
L1C77F7: db $FF
L1C77F8: db $DC
L1C77F9: db $B6
L1C77FA: db $DE
L1C77FB: db $B7
L1C77FC: db $AE
L1C77FD: db $B8
L1C77FE: db $B9
L1C77FF: db $DE
L1C7800: db $DD
L1C7801: db $D8
L1C7802: db $AD
L1C7803: db $B3
L1C7804: db $C6
L1C7805: db $FF
L1C7806: db $FF
L1C7807: db $C3
L1C7808: db $B7
L1C7809: db $CA
L1C780A: db $B2
L1C780B: db $C5
L1C780C: db $B2
L1C780D: db $A1
L1C780E: db $FF
L1C780F: db $0C
L1C7810: db $B8
L1C7811: db $DE
L1C7812: db $B3
L1C7813: db $B5
L1C7814: db $B5
L1C7815: db $B5
L1C7816: db $B3
L1C7817: db $B3
L1C7818: db $B3
L1C7819: db $21
L1C781A: db $21
L1C781B: db $FF
L1C781C: db $0B
L1C781D: db $A5
L1C781E: db $A5
L1C781F: db $A5
L1C7820: db $A5
L1C7821: db $A5
L1C7822: db $A5
L1C7823: db $A5
L1C7824: db $A5
L1C7825: db $A5
L1C7826: db $A5
L1C7827: db $FF
L1C7828: db $34
L1C7829: db $C5
L1C782A: db $C6
L1C782B: db $BA
L1C782C: db $DE
L1C782D: db $C4
L1C782E: db $C6
L1C782F: db $D3
L1C7830: db $BE
L1C7831: db $DE
L1C7832: db $DD
L1C7833: db $D8
L1C7834: db $AE
L1C7835: db $B8
L1C7836: db $C3
L1C7837: db $DE
L1C7838: db $FF
L1C7839: db $FF
L1C783A: db $B2
L1C783B: db $C4
L1C783C: db $DE
L1C783D: db $D1
L1C783E: db $21
L1C783F: db $20
L1C7840: db $BF
L1C7841: db $DA
L1C7842: db $B6
L1C7843: db $DE
L1C7844: db $B2
L1C7845: db $C2
L1C7846: db $B6
L1C7847: db $BC
L1C7848: db $AE
L1C7849: db $B3
L1C784A: db $D8
L1C784B: db $FF
L1C784C: db $FF
L1C784D: db $BD
L1C784E: db $D9
L1C784F: db $B7
L1C7850: db $CE
L1C7851: db $DE
L1C7852: db $B3
L1C7853: db $C6
L1C7854: db $C2
L1C7855: db $C5
L1C7856: db $B6
L1C7857: db $DE
L1C7858: db $D9
L1C7859: db $C9
L1C785A: db $D6
L1C785B: db $A1
L1C785C: db $FF
L1C785D: db $20
L1C785E: db $B5
L1C785F: db $D2
L1C7860: db $C3
L1C7861: db $DE
L1C7862: db $C4
L1C7863: db $B3
L1C7864: db $BA
L1C7865: db $DE
L1C7866: db $BB
L1C7867: db $DE
L1C7868: db $B2
L1C7869: db $CF
L1C786A: db $BD
L1C786B: db $A1
L1C786C: db $FF
L1C786D: db $FF
L1C786E: db $BD
L1C786F: db $CA
L1C7870: db $DE
L1C7871: db $D7
L1C7872: db $BC
L1C7873: db $B2
L1C7874: db $BC
L1C7875: db $B1
L1C7876: db $B2
L1C7877: db $C3
L1C7878: db $DE
L1C7879: db $BC
L1C787A: db $C0
L1C787B: db $DC
L1C787C: db $A1
L1C787D: db $FF
L1C787E: db $27
L1C787F: db $DC
L1C7880: db $C0
L1C7881: db $BC
L1C7882: db $C9
L1C7883: db $C5
L1C7884: db $CA
L1C7885: db $A4
L1C7886: db $B6
L1C7887: db $B8
L1C7888: db $DE
L1C7889: db $D7
L1C788A: db $C1
L1C788B: db $C2
L1C788C: db $DE
L1C788D: db $D9
L1C788E: db $A5
L1C788F: db $A5
L1C7890: db $A5
L1C7891: db $FF
L1C7892: db $FF
L1C7893: db $BA
L1C7894: db $DD
L1C7895: db $C0
L1C7896: db $B2
L1C7897: db $B6
L1C7898: db $B2
L1C7899: db $A6
L1C789A: db $BC
L1C789B: db $AD
L1C789C: db $BB
L1C789D: db $B2
L1C789E: db $BC
L1C789F: db $C0
L1C78A0: db $D3
L1C78A1: db $C9
L1C78A2: db $C3
L1C78A3: db $DE
L1C78A4: db $BD
L1C78A5: db $FF
L1C78A6: db $28
L1C78A7: db $52
L1C78A8: db $55
L1C78A9: db $47
L1C78AA: db $41
L1C78AB: db $4C
L1C78AC: db $A6
L1C78AD: db $C0
L1C78AE: db $B5
L1C78AF: db $BC
L1C78B0: db $C0
L1C78B1: db $BF
L1C78B2: db $C9
L1C78B3: db $C1
L1C78B4: db $B6
L1C78B5: db $D7
L1C78B6: db $FF
L1C78B7: db $FF
L1C78B8: db $C9
L1C78B9: db $CE
L1C78BA: db $C4
L1C78BB: db $DE
L1C78BC: db $CA
L1C78BD: db $B2
L1C78BE: db $B9
L1C78BF: db $DD
L1C78C0: db $BC
L1C78C1: db $C0
L1C78C2: db $B6
L1C78C3: db $AF
L1C78C4: db $C0
L1C78C5: db $FF
L1C78C6: db $FF
L1C78C7: db $C9
L1C78C8: db $C3
L1C78C9: db $DE
L1C78CA: db $BD
L1C78CB: db $B6
L1C78CC: db $DE
L1C78CD: db $A1
L1C78CE: db $FF
L1C78CF: db $18
L1C78D0: db $B1
L1C78D1: db $C5
L1C78D2: db $C0
L1C78D3: db $C0
L1C78D4: db $C1
L1C78D5: db $C9
L1C78D6: db $CE
L1C78D7: db $DD
L1C78D8: db $C4
L1C78D9: db $B3
L1C78DA: db $C9
L1C78DB: db $C1
L1C78DC: db $B6
L1C78DD: db $D7
L1C78DE: db $B6
L1C78DF: db $DE
L1C78E0: db $FF
L1C78E1: db $FF
L1C78E2: db $D0
L1C78E3: db $C0
L1C78E4: db $B2
L1C78E5: db $DC
L1C78E6: db $A1
L1C78E7: db $FF
L1C78E8: db $2F
L1C78E9: db $69
L1C78EA: db $B0
L1C78EB: db $6A
L1C78EC: db $6E
L1C78ED: db $71
L1C78EE: db $69
L1C78EF: db $C3
L1C78F0: db $DE
L1C78F1: db $D0
L1C78F2: db $BE
L1C78F3: db $C0
L1C78F4: db $C9
L1C78F5: db $B6
L1C78F6: db $DE
L1C78F7: db $FF
L1C78F8: db $FF
L1C78F9: db $BC
L1C78FA: db $DE
L1C78FB: db $C2
L1C78FC: db $D8
L1C78FD: db $AE
L1C78FE: db $B8
L1C78FF: db $C4
L1C7900: db $B2
L1C7901: db $B3
L1C7902: db $C9
L1C7903: db $C5
L1C7904: db $D7
L1C7905: db $FF
L1C7906: db $FF
L1C7907: db $CA
L1C7908: db $C5
L1C7909: db $BC
L1C790A: db $CA
L1C790B: db $CD
L1C790C: db $DE
L1C790D: db $C2
L1C790E: db $C0
L1C790F: db $DE
L1C7910: db $B9
L1C7911: db $C4
L1C7912: db $DE
L1C7913: db $A5
L1C7914: db $A5
L1C7915: db $A5
L1C7916: db $A1
L1C7917: db $FF
L1C7918: db $0F
L1C7919: db $C5
L1C791A: db $BE
L1C791B: db $DE
L1C791C: db $52
L1C791D: db $55
L1C791E: db $47
L1C791F: db $41
L1C7920: db $4C
L1C7921: db $C9
L1C7922: db $BA
L1C7923: db $C4
L1C7924: db $A6
L1C7925: db $21
L1C7926: db $3F
L1C7927: db $FF
L1C7928: db $22
L1C7929: db $52
L1C792A: db $55
L1C792B: db $47
L1C792C: db $41
L1C792D: db $4C
L1C792E: db $B6
L1C792F: db $DE
L1C7930: db $C3
L1C7931: db $C6
L1C7932: db $B2
L1C7933: db $DA
L1C7934: db $D6
L1C7935: db $B3
L1C7936: db $C4
L1C7937: db $BC
L1C7938: db $C3
L1C7939: db $FF
L1C793A: db $FF
L1C793B: db $C3
L1C793C: db $DE
L1C793D: db $B7
L1C793E: db $C5
L1C793F: db $B6
L1C7940: db $AF
L1C7941: db $C0
L1C7942: db $63
L1C7943: db $6F
L1C7944: db $67
L1C7945: db $C9
L1C7946: db $C1
L1C7947: db $B6
L1C7948: db $D7
L1C7949: db $A1
L1C794A: db $FF
L1C794B: db $1C
L1C794C: db $CC
L1C794D: db $B3
L1C794E: db $BC
L1C794F: db $DE
L1C7950: db $D7
L1C7951: db $DA
L1C7952: db $BC
L1C7953: db $A4
L1C7954: db $BF
L1C7955: db $C9
L1C7956: db $C1
L1C7957: db $B6
L1C7958: db $D7
L1C7959: db $A6
L1C795A: db $FF
L1C795B: db $FF
L1C795C: db $DC
L1C795D: db $C0
L1C795E: db $BC
L1C795F: db $CA
L1C7960: db $CF
L1C7961: db $D3
L1C7962: db $AF
L1C7963: db $C3
L1C7964: db $B7
L1C7965: db $C0
L1C7966: db $A1
L1C7967: db $FF
L1C7968: db $12
L1C7969: db $BF
L1C796A: db $DA
L1C796B: db $A6
L1C796C: db $52
L1C796D: db $55
L1C796E: db $47
L1C796F: db $41
L1C7970: db $4C
L1C7971: db $B6
L1C7972: db $DE
L1C7973: db $B6
L1C7974: db $B2
L1C7975: db $CE
L1C7976: db $B3
L1C7977: db $BC
L1C7978: db $C0
L1C7979: db $3F
L1C797A: db $FF
L1C797B: db $24
L1C797C: db $52
L1C797D: db $55
L1C797E: db $47
L1C797F: db $41
L1C7980: db $4C
L1C7981: db $CA
L1C7982: db $A4
L1C7983: db $B6
L1C7984: db $B2
L1C7985: db $CE
L1C7986: db $B3
L1C7987: db $BB
L1C7988: db $DA
L1C7989: db $C0
L1C798A: db $C1
L1C798B: db $B6
L1C798C: db $D7
L1C798D: db $A6
L1C798E: db $FF
L1C798F: db $FF
L1C7990: db $D6
L1C7991: db $BA
L1C7992: db $B6
L1C7993: db $D7
L1C7994: db $B3
L1C7995: db $CA
L1C7996: db $DE
L1C7997: db $B2
L1C7998: db $C4
L1C7999: db $AF
L1C799A: db $C0
L1C799B: db $C0
L1C799C: db $DE
L1C799D: db $B9
L1C799E: db $A1
L1C799F: db $FF
L1C79A0: db $1F
L1C79A1: db $BF
L1C79A2: db $DA
L1C79A3: db $C4
L1C79A4: db $A4
L1C79A5: db $B1
L1C79A6: db $C5
L1C79A7: db $C0
L1C79A8: db $C4
L1C79A9: db $C0
L1C79AA: db $C0
L1C79AB: db $B6
L1C79AC: db $AF
L1C79AD: db $C0
L1C79AE: db $BA
L1C79AF: db $C4
L1C79B0: db $C4
L1C79B1: db $FF
L1C79B2: db $FF
L1C79B3: db $C4
L1C79B4: db $DE
L1C79B5: db $B3
L1C79B6: db $B2
L1C79B7: db $B3
L1C79B8: db $B6
L1C79B9: db $DD
L1C79BA: db $B9
L1C79BB: db $B2
L1C79BC: db $B6
L1C79BD: db $DE
L1C79BE: db $3F
L1C79BF: db $FF
L1C79C0: db $21
L1C79C1: db $B1
L1C79C2: db $C5
L1C79C3: db $C0
L1C79C4: db $C0
L1C79C5: db $C1
L1C79C6: db $C9
L1C79C7: db $BC
L1C79C8: db $DE
L1C79C9: db $C2
L1C79CA: db $D8
L1C79CB: db $AE
L1C79CC: db $B8
L1C79CD: db $A6
L1C79CE: db $D0
L1C79CF: db $D9
L1C79D0: db $C0
L1C79D1: db $D2
L1C79D2: db $C6
L1C79D3: db $FF
L1C79D4: db $FF
L1C79D5: db $69
L1C79D6: db $2D
L1C79D7: db $6A
L1C79D8: db $6E
L1C79D9: db $71
L1C79DA: db $69
L1C79DB: db $A6
L1C79DC: db $CB
L1C79DD: db $D7
L1C79DE: db $B2
L1C79DF: db $C0
L1C79E0: db $A1
L1C79E1: db $FF
L1C79E2: db $08
L1C79E3: db $C5
L1C79E4: db $DD
L1C79E5: db $C9
L1C79E6: db $C0
L1C79E7: db $D2
L1C79E8: db $C6
L1C79E9: db $3F
L1C79EA: db $FF
L1C79EB: db $31
L1C79EC: db $63
L1C79ED: db $6F
L1C79EE: db $67
L1C79EF: db $C9
L1C79F0: db $C1
L1C79F1: db $B6
L1C79F2: db $D7
L1C79F3: db $A6
L1C79F4: db $CC
L1C79F5: db $B3
L1C79F6: db $BC
L1C79F7: db $DE
L1C79F8: db $D9
L1C79F9: db $C9
L1C79FA: db $C6
L1C79FB: db $A4
L1C79FC: db $FF
L1C79FD: db $FF
L1C79FE: db $B1
L1C79FF: db $C5
L1C7A00: db $C0
L1C7A01: db $C9
L1C7A02: db $C1
L1C7A03: db $B6
L1C7A04: db $D7
L1C7A05: db $A6
L1C7A06: db $B6
L1C7A07: db $BC
L1C7A08: db $C3
L1C7A09: db $CE
L1C7A0A: db $BC
L1C7A0B: db $B2
L1C7A0C: db $C9
L1C7A0D: db $D6
L1C7A0E: db $A1
L1C7A0F: db $FF
L1C7A10: db $FF
L1C7A11: db $BC
L1C7A12: db $DE
L1C7A13: db $B6
L1C7A14: db $DD
L1C7A15: db $CA
L1C7A16: db $D3
L1C7A17: db $B3
L1C7A18: db $C5
L1C7A19: db $B2
L1C7A1A: db $DC
L1C7A1B: db $A1
L1C7A1C: db $FF
L1C7A1D: db $1C
L1C7A1E: db $B9
L1C7A1F: db $CA
L1C7A20: db $B2
L1C7A21: db $C3
L1C7A22: db $DE
L1C7A23: db $DC
L1C7A24: db $B6
L1C7A25: db $D9
L1C7A26: db $C9
L1C7A27: db $A1
L1C7A28: db $FF
L1C7A29: db $FF
L1C7A2A: db $D3
L1C7A2B: db $B3
L1C7A2C: db $BF
L1C7A2D: db $BA
L1C7A2E: db $CF
L1C7A2F: db $C3
L1C7A30: db $DE
L1C7A31: db $B7
L1C7A32: db $C3
L1C7A33: db $B2
L1C7A34: db $D9
L1C7A35: db $A5
L1C7A36: db $A5
L1C7A37: db $A5
L1C7A38: db $A1
L1C7A39: db $FF
L1C7A3A: db $06
L1C7A3B: db $B7
L1C7A3C: db $C3
L1C7A3D: db $B2
L1C7A3E: db $D9
L1C7A3F: db $3F
L1C7A40: db $FF
L1C7A41: db $23
L1C7A42: db $BF
L1C7A43: db $B3
L1C7A44: db $A5
L1C7A45: db $A5
L1C7A46: db $A5
L1C7A47: db $A1
L1C7A48: db $CC
L1C7A49: db $B3
L1C7A4A: db $BC
L1C7A4B: db $DE
L1C7A4C: db $D7
L1C7A4D: db $DA
L1C7A4E: db $C3
L1C7A4F: db $B2
L1C7A50: db $C0
L1C7A51: db $FF
L1C7A52: db $FF
L1C7A53: db $63
L1C7A54: db $6F
L1C7A55: db $67
L1C7A56: db $A6
L1C7A57: db $B6
L1C7A58: db $B2
L1C7A59: db $CE
L1C7A5A: db $B3
L1C7A5B: db $BC
L1C7A5C: db $C0
L1C7A5D: db $B5
L1C7A5E: db $C4
L1C7A5F: db $BA
L1C7A60: db $A5
L1C7A61: db $A5
L1C7A62: db $A5
L1C7A63: db $A1
L1C7A64: db $FF
L1C7A65: db $10
L1C7A66: db $C5
L1C7A67: db $A4
L1C7A68: db $C5
L1C7A69: db $C6
L1C7A6A: db $21
L1C7A6B: db $3F
L1C7A6C: db $20
L1C7A6D: db $20
L1C7A6E: db $B6
L1C7A6F: db $BE
L1C7A70: db $DE
L1C7A71: db $B6
L1C7A72: db $DE
L1C7A73: db $21
L1C7A74: db $3F
L1C7A75: db $FF
L1C7A76: db $06
L1C7A77: db $B3
L1C7A78: db $DC
L1C7A79: db $B1
L1C7A7A: db $B0
L1C7A7B: db $21
L1C7A7C: db $FF
L1C7A7D: db $27
L1C7A7E: db $BB
L1C7A7F: db $BD
L1C7A80: db $B6
L1C7A81: db $DE
L1C7A82: db $C3
L1C7A83: db $DE
L1C7A84: db $BD
L1C7A85: db $C8
L1C7A86: db $A1
L1C7A87: db $BA
L1C7A88: db $DA
L1C7A89: db $B8
L1C7A8A: db $DE
L1C7A8B: db $D7
L1C7A8C: db $B2
L1C7A8D: db $C3
L1C7A8E: db $DE
L1C7A8F: db $CA
L1C7A90: db $FF
L1C7A91: db $FF
L1C7A92: db $C4
L1C7A93: db $DE
L1C7A94: db $B3
L1C7A95: db $C4
L1C7A96: db $B2
L1C7A97: db $B3
L1C7A98: db $BA
L1C7A99: db $C4
L1C7A9A: db $CA
L1C7A9B: db $B1
L1C7A9C: db $D8
L1C7A9D: db $CF
L1C7A9E: db $BE
L1C7A9F: db $DD
L1C7AA0: db $B6
L1C7AA1: db $A5
L1C7AA2: db $A5
L1C7AA3: db $A5
L1C7AA4: db $FF
L1C7AA5: db $05
L1C7AA6: db $C0
L1C7AA7: db $DE
L1C7AA8: db $DA
L1C7AA9: db $3F
L1C7AAA: db $FF
L1C7AAB: db $19
L1C7AAC: db $CA
L1C7AAD: db $BC
L1C7AAE: db $DE
L1C7AAF: db $D2
L1C7AB0: db $CF
L1C7AB1: db $BC
L1C7AB2: db $C3
L1C7AB3: db $A1
L1C7AB4: db $FF
L1C7AB5: db $FF
L1C7AB6: db $47
L1C7AB7: db $4F
L1C7AB8: db $45
L1C7AB9: db $4E
L1C7ABA: db $49
L1C7ABB: db $54
L1C7ABC: db $5A
L1C7ABD: db $C4
L1C7ABE: db $D3
L1C7ABF: db $B3
L1C7AC0: db $BC
L1C7AC1: db $CF
L1C7AC2: db $BD
L1C7AC3: db $2E
L1C7AC4: db $FF
L1C7AC5: db $2A
L1C7AC6: db $B2
L1C7AC7: db $CF
L1C7AC8: db $CF
L1C7AC9: db $C3
L1C7ACA: db $DE
L1C7ACB: db $C9
L1C7ACC: db $BA
L1C7ACD: db $C4
L1C7ACE: db $CA
L1C7ACF: db $A4
L1C7AD0: db $CA
L1C7AD1: db $B2
L1C7AD2: db $B9
L1C7AD3: db $DD
L1C7AD4: db $BB
L1C7AD5: db $BE
L1C7AD6: db $C3
L1C7AD7: db $FF
L1C7AD8: db $FF
L1C7AD9: db $B2
L1C7ADA: db $C0
L1C7ADB: db $C0
L1C7ADC: db $DE
L1C7ADD: db $B7
L1C7ADE: db $CF
L1C7ADF: db $BC
L1C7AE0: db $C0
L1C7AE1: db $A1
L1C7AE2: db $FF
L1C7AE3: db $FF
L1C7AE4: db $BC
L1C7AE5: db $B6
L1C7AE6: db $BC
L1C7AE7: db $A4
L1C7AE8: db $D1
L1C7AE9: db $C0
L1C7AEA: db $DE
L1C7AEB: db $C3
L1C7AEC: db $DE
L1C7AED: db $BD
L1C7AEE: db $A1
L1C7AEF: db $FF
L1C7AF0: db $26
L1C7AF1: db $B1
L1C7AF2: db $C5
L1C7AF3: db $C0
L1C7AF4: db $C0
L1C7AF5: db $C1
L1C7AF6: db $C6
L1C7AF7: db $CA
L1C7AF8: db $C5
L1C7AF9: db $C6
L1C7AFA: db $D3
L1C7AFB: db $C3
L1C7AFC: db $DE
L1C7AFD: db $B7
L1C7AFE: db $CF
L1C7AFF: db $BE
L1C7B00: db $DD
L1C7B01: db $A1
L1C7B02: db $FF
L1C7B03: db $FF
L1C7B04: db $C4
L1C7B05: db $B8
L1C7B06: db $CD
L1C7B07: db $DE
L1C7B08: db $C2
L1C7B09: db $C6
L1C7B0A: db $BE
L1C7B0B: db $DD
L1C7B0C: db $C0
L1C7B0D: db $B8
L1C7B0E: db $BC
L1C7B0F: db $A6
L1C7B10: db $B1
L1C7B11: db $B9
L1C7B12: db $DE
L1C7B13: db $CF
L1C7B14: db $BD
L1C7B15: db $A1
L1C7B16: db $FF
L1C7B17: db $17
L1C7B18: db $C0
L1C7B19: db $C0
L1C7B1A: db $B6
L1C7B1B: db $DC
L1C7B1C: db $BD
L1C7B1D: db $DE
L1C7B1E: db $C6
L1C7B1F: db $BC
L1C7B20: db $C7
L1C7B21: db $B6
L1C7B22: db $A4
L1C7B23: db $FF
L1C7B24: db $FF
L1C7B25: db $C0
L1C7B26: db $C0
L1C7B27: db $B6
L1C7B28: db $AF
L1C7B29: db $C3
L1C7B2A: db $BC
L1C7B2B: db $C7
L1C7B2C: db $B6
L1C7B2D: db $A1
L1C7B2E: db $FF
L1C7B2F: db $16
L1C7B30: db $C4
L1C7B31: db $DE
L1C7B32: db $C1
L1C7B33: db $D7
L1C7B34: db $C3
L1C7B35: db $DE
L1C7B36: db $D3
L1C7B37: db $C5
L1C7B38: db $B2
L1C7B39: db $21
L1C7B3A: db $FF
L1C7B3B: db $FF
L1C7B3C: db $C0
L1C7B3D: db $C0
L1C7B3E: db $B6
L1C7B3F: db $AF
L1C7B40: db $C3
L1C7B41: db $B6
L1C7B42: db $C2
L1C7B43: db $21
L1C7B44: db $21
L1C7B45: db $FF
L1C7B46: db $17
L1C7B47: db $B5
L1C7B48: db $C4
L1C7B49: db $DE
L1C7B4A: db $DB
L1C7B4B: db $B7
L1C7B4C: db $C3
L1C7B4D: db $DE
L1C7B4E: db $BD
L1C7B4F: db $C8
L1C7B50: db $A1
L1C7B51: db $FF
L1C7B52: db $FF
L1C7B53: db $BA
L1C7B54: db $DA
L1C7B55: db $CE
L1C7B56: db $C4
L1C7B57: db $DE
L1C7B58: db $C4
L1C7B59: db $CA
L1C7B5A: db $A5
L1C7B5B: db $A5
L1C7B5C: db $A5
L1C7B5D: db $FF
L1C7B5E: db $2F
L1C7B5F: db $BC
L1C7B60: db $B6
L1C7B61: db $BC
L1C7B62: db $A4
L1C7B63: db $B1
L1C7B64: db $C5
L1C7B65: db $C0
L1C7B66: db $B6
L1C7B67: db $DE
L1C7B68: db $C0
L1C7B69: db $C9
L1C7B6A: db $C3
L1C7B6B: db $C3
L1C7B6C: db $DE
L1C7B6D: db $63
L1C7B6E: db $6F
L1C7B6F: db $67
L1C7B70: db $A6
L1C7B71: db $FF
L1C7B72: db $FF
L1C7B73: db $CC
L1C7B74: db $B3
L1C7B75: db $BC
L1C7B76: db $DE
L1C7B77: db $D6
L1C7B78: db $B3
L1C7B79: db $C5
L1C7B7A: db $C4
L1C7B7B: db $DE
L1C7B7C: db $C4
L1C7B7D: db $CA
L1C7B7E: db $B6
L1C7B7F: db $DD
L1C7B80: db $B6
L1C7B81: db $DE
L1C7B82: db $B4
L1C7B83: db $C5
L1C7B84: db $B2
L1C7B85: db $FF
L1C7B86: db $FF
L1C7B87: db $BA
L1C7B88: db $C4
L1C7B89: db $C3
L1C7B8A: db $DE
L1C7B8B: db $BD
L1C7B8C: db $A1
L1C7B8D: db $FF
L1C7B8E: db $11
L1C7B8F: db $C3
L1C7B90: db $A6
L1C7B91: db $CB
L1C7B92: db $B8
L1C7B93: db $BA
L1C7B94: db $C4
L1C7B95: db $A6
L1C7B96: db $B5
L1C7B97: db $BD
L1C7B98: db $BD
L1C7B99: db $D2
L1C7B9A: db $BC
L1C7B9B: db $CF
L1C7B9C: db $BD
L1C7B9D: db $D6
L1C7B9E: db $A1
L1C7B9F: db $FF
L1C7BA0: db $16
L1C7BA1: db $CC
L1C7BA2: db $B3
L1C7BA3: db $BC
L1C7BA4: db $DE
L1C7BA5: db $C3
L1C7BA6: db $D0
L1C7BA7: db $BE
L1C7BA8: db $D9
L1C7BA9: db $DC
L1C7BAA: db $A1
L1C7BAB: db $FF
L1C7BAC: db $FF
L1C7BAD: db $B6
L1C7BAE: db $C5
L1C7BAF: db $D7
L1C7BB0: db $BD
L1C7BB1: db $DE
L1C7BB2: db $A5
L1C7BB3: db $A5
L1C7BB4: db $A5
L1C7BB5: db $A1
L1C7BB6: db $FF
L1C7BB7: db $2A
L1C7BB8: db $B6
L1C7BB9: db $C1
L1C7BBA: db $B7
L1C7BBB: db $C5
L1C7BBC: db $B5
L1C7BBD: db $B6
L1C7BBE: db $C0
L1C7BBF: db $C0
L1C7BC0: db $DE
L1C7BC1: db $A5
L1C7BC2: db $A5
L1C7BC3: db $A5
L1C7BC4: db $A1
L1C7BC5: db $FF
L1C7BC6: db $FF
L1C7BC7: db $B2
L1C7BC8: db $B2
L1C7BC9: db $B6
L1C7BCA: db $BE
L1C7BCB: db $DE
L1C7BCC: db $B6
L1C7BCD: db $DE
L1C7BCE: db $B7
L1C7BCF: db $CF
L1C7BD0: db $BC
L1C7BD1: db $C0
L1C7BD2: db $A1
L1C7BD3: db $FF
L1C7BD4: db $FF
L1C7BD5: db $BF
L1C7BD6: db $DB
L1C7BD7: db $BF
L1C7BD8: db $DB
L1C7BD9: db $BA
L1C7BDA: db $DB
L1C7BDB: db $B1
L1C7BDC: db $B2
L1C7BDD: db $C3
L1C7BDE: db $DE
L1C7BDF: db $BD
L1C7BE0: db $A1
L1C7BE1: db $FF
L1C7BE2: db $07
L1C7BE3: db $C6
L1C7BE4: db $B9
L1C7BE5: db $DE
L1C7BE6: db $D9
L1C7BE7: db $21
L1C7BE8: db $3F
L1C7BE9: db $FF
L1C7BEA: db $0D
L1C7BEB: db $B2
L1C7BEC: db $B4
L1C7BED: db $A4
L1C7BEE: db $D2
L1C7BEF: db $BB
L1C7BF0: db $DA
L1C7BF1: db $D9
L1C7BF2: db $C9
L1C7BF3: db $C3
L1C7BF4: db $DE
L1C7BF5: db $BD
L1C7BF6: db $A1
L1C7BF7: db $FF
L1C7BF8: db $09
L1C7BF9: db $A5
L1C7BFA: db $A5
L1C7BFB: db $A5
L1C7BFC: db $C3
L1C7BFD: db $DD
L1C7BFE: db $20
L1C7BFF: db $CD
L1C7C00: db $A1
L1C7C01: db $FF
L1C7C02: db $26
L1C7C03: db $BA
L1C7C04: db $C9
L1C7C05: db $B8
L1C7C06: db $DE
L1C7C07: db $D7
L1C7C08: db $B2
L1C7C09: db $C9
L1C7C0A: db $BC
L1C7C0B: db $DE
L1C7C0C: db $C2
L1C7C0D: db $D8
L1C7C0E: db $AE
L1C7C0F: db $B8
L1C7C10: db $C3
L1C7C11: db $DE
L1C7C12: db $CA
L1C7C13: db $A4
L1C7C14: db $FF
L1C7C15: db $FF
L1C7C16: db $DC
L1C7C17: db $C0
L1C7C18: db $BC
L1C7C19: db $B6
L1C7C1A: db $DE
L1C7C1B: db $C3
L1C7C1C: db $DE
L1C7C1D: db $D9
L1C7C1E: db $CF
L1C7C1F: db $C3
L1C7C20: db $DE
L1C7C21: db $D3
L1C7C22: db $B1
L1C7C23: db $D8
L1C7C24: db $CF
L1C7C25: db $BE
L1C7C26: db $DD
L1C7C27: db $A1
L1C7C28: db $FF
L1C7C29: db $1C
L1C7C2A: db $4E
L1C7C2B: db $4F
L1C7C2C: db $52
L1C7C2D: db $4D
L1C7C2E: db $41
L1C7C2F: db $4C
L1C7C30: db $B2
L1C7C31: db $BC
L1C7C32: db $DE
L1C7C33: db $AE
L1C7C34: db $B3
L1C7C35: db $C3
L1C7C36: db $DE
L1C7C37: db $FF
L1C7C38: db $FF
L1C7C39: db $B5
L1C7C3A: db $B1
L1C7C3B: db $B2
L1C7C3C: db $BC
L1C7C3D: db $CF
L1C7C3E: db $BC
L1C7C3F: db $AE
L1C7C40: db $B3
L1C7C41: db $A5
L1C7C42: db $A5
L1C7C43: db $A5
L1C7C44: db $A1
L1C7C45: db $FF
L1C7C46: db $15
L1C7C47: db $20
L1C7C48: db $20
L1C7C49: db $20
L1C7C4A: db $20
L1C7C4B: db $20
L1C7C4C: db $20
L1C7C4D: db $20
L1C7C4E: db $20
L1C7C4F: db $20
L1C7C50: db $20
L1C7C51: db $20
L1C7C52: db $20
L1C7C53: db $20
L1C7C54: db $20
L1C7C55: db $20
L1C7C56: db $20
L1C7C57: db $20
L1C7C58: db $20
L1C7C59: db $20
L1C7C5A: db $20
L1C7C5B: db $FF
L1C7C5C: db $27
L1C7C5D: db $D0
L1C7C5E: db $C5
L1C7C5F: db $BB
L1C7C60: db $DD
L1C7C61: db $A4
L1C7C62: db $B1
L1C7C63: db $D8
L1C7C64: db $B6
L1C7C65: db $DE
L1C7C66: db $C4
L1C7C67: db $B3
L1C7C68: db $A1
L1C7C69: db $FF
L1C7C6A: db $FF
L1C7C6B: db $BA
L1C7C6C: db $DA
L1C7C6D: db $C3
L1C7C6E: db $DE
L1C7C6F: db $B1
L1C7C70: db $C9
L1C7C71: db $B5
L1C7C72: db $C4
L1C7C73: db $BA
L1C7C74: db $C9
L1C7C75: db $B9
L1C7C76: db $DE
L1C7C77: db $DD
L1C7C78: db $BF
L1C7C79: db $B3
L1C7C7A: db $D3
L1C7C7B: db $FF
L1C7C7C: db $FF
L1C7C7D: db $B7
L1C7C7E: db $B4
L1C7C7F: db $CF
L1C7C80: db $BC
L1C7C81: db $C0
L1C7C82: db $A1
L1C7C83: db $FF
L1C7C84: db $3A
L1C7C85: db $C3
L1C7C86: db $DE
L1C7C87: db $D3
L1C7C88: db $A4
L1C7C89: db $B8
L1C7C8A: db $D7
L1C7C8B: db $D4
L1C7C8C: db $D0
L1C7C8D: db $C3
L1C7C8E: db $DE
L1C7C8F: db $B3
L1C7C90: db $BA
L1C7C91: db $DE
L1C7C92: db $D2
L1C7C93: db $B8
L1C7C94: db $D3
L1C7C95: db $C9
L1C7C96: db $FF
L1C7C97: db $FF
L1C7C98: db $C4
L1C7C99: db $DE
L1C7C9A: db $D3
L1C7C9B: db $CA
L1C7C9C: db $A4
L1C7C9D: db $B2
L1C7C9E: db $C2
L1C7C9F: db $A4
L1C7CA0: db $CB
L1C7CA1: db $C4
L1C7CA2: db $CB
L1C7CA3: db $DE
L1C7CA4: db $C4
L1C7CA5: db $A6
L1C7CA6: db $BF
L1C7CA7: db $C9
L1C7CA8: db $D4
L1C7CA9: db $D0
L1C7CAA: db $FF
L1C7CAB: db $FF
L1C7CAC: db $C6
L1C7CAD: db $C2
L1C7CAE: db $C2
L1C7CAF: db $D0
L1C7CB0: db $BA
L1C7CB1: db $D3
L1C7CB2: db $B3
L1C7CB3: db $C4
L1C7CB4: db $BD
L1C7CB5: db $D9
L1C7CB6: db $B6
L1C7CB7: db $DC
L1C7CB8: db $B6
L1C7CB9: db $D8
L1C7CBA: db $CF
L1C7CBB: db $BE
L1C7CBC: db $DD
L1C7CBD: db $A1
L1C7CBE: db $FF
L1C7CBF: db $32
L1C7CC0: db $BF
L1C7CC1: db $DA
L1C7CC2: db $CA
L1C7CC3: db $A4
L1C7CC4: db $C1
L1C7CC5: db $B6
L1C7CC6: db $B2
L1C7CC7: db $BC
L1C7CC8: db $AE
L1C7CC9: db $B3
L1C7CCA: db $D7
L1C7CCB: db $B2
L1C7CCC: db $A4
L1C7CCD: db $B5
L1C7CCE: db $C4
L1C7CCF: db $BD
L1C7CD0: db $DE
L1C7CD1: db $FF
L1C7CD2: db $FF
L1C7CD3: db $DA
L1C7CD4: db $D9
L1C7CD5: db $B6
L1C7CD6: db $D3
L1C7CD7: db $A5
L1C7CD8: db $A5
L1C7CD9: db $A5
L1C7CDA: db $A1
L1C7CDB: db $20
L1C7CDC: db $20
L1C7CDD: db $BF
L1C7CDE: db $C9
L1C7CDF: db $C4
L1C7CE0: db $B7
L1C7CE1: db $CA
L1C7CE2: db $A4
L1C7CE3: db $FF
L1C7CE4: db $FF
L1C7CE5: db $CF
L1C7CE6: db $C0
L1C7CE7: db $A4
L1C7CE8: db $B5
L1C7CE9: db $B1
L1C7CEA: db $B2
L1C7CEB: db $BC
L1C7CEC: db $CF
L1C7CED: db $BC
L1C7CEE: db $AE
L1C7CEF: db $B3
L1C7CF0: db $A1
L1C7CF1: db $FF
L1C7CF2: db $3E
L1C7CF3: db $54
L1C7CF4: db $41
L1C7CF5: db $4B
L1C7CF6: db $41
L1C7CF7: db $52
L1C7CF8: db $41
L1C7CF9: db $6F
L1C7CFA: db $65
L1C7CFB: db $DE
L1C7CFC: db $C9
L1C7CFD: db $CB
L1C7CFE: db $AE
L1C7CFF: db $B3
L1C7D00: db $BC
L1C7D01: db $DE
L1C7D02: db $FF
L1C7D03: db $FF
L1C7D04: db $C1
L1C7D05: db $AD
L1C7D06: db $B3
L1C7D07: db $C6
L1C7D08: db $53
L1C7D09: db $45
L1C7D0A: db $4C
L1C7D0B: db $45
L1C7D0C: db $43
L1C7D0D: db $54
L1C7D0E: db $72
L1C7D0F: db $DE
L1C7D10: db $73
L1C7D11: db $71
L1C7D12: db $A6
L1C7D13: db $FF
L1C7D14: db $FF
L1C7D15: db $33
L1C7D16: db $B6
L1C7D17: db $B2
L1C7D18: db $B5
L1C7D19: db $BD
L1C7D1A: db $C4
L1C7D1B: db $A4
L1C7D1C: db $FF
L1C7D1D: db $FF
L1C7D1E: db $47
L1C7D1F: db $4F
L1C7D20: db $45
L1C7D21: db $4E
L1C7D22: db $49
L1C7D23: db $54
L1C7D24: db $5A
L1C7D25: db $B6
L1C7D26: db $DE
L1C7D27: db $BC
L1C7D28: db $D6
L1C7D29: db $B3
L1C7D2A: db $C3
L1C7D2B: db $DE
L1C7D2C: db $B7
L1C7D2D: db $CF
L1C7D2E: db $BD
L1C7D2F: db $A1
L1C7D30: db $FF

; =============== MoveC_Base_NormL_2Hit_D06_A03 ===============
; Generic move code used for light normals that hit twice.
; See also: MoveC_Base_NormH_2Hit_D06_A04
MoveC_Base_NormL_2Hit_D06_A03:
	call Play_Pl_MoveByColiBoxOverlapX
	mMvC_ValLoaded .ret
	
	; Depending on the visible frame...
	ld   hl, iOBJInfo_OBJLstPtrTblOffsetView
	add  hl, de
	ld   a, [hl]		; A = OBJLst ID
	cp   $00*OBJLSTPTR_ENTRYSIZE
	jp   z, .obj0
; --------------- frame #1-(end) ---------------
	mMvC_ChkTarget .chkEnd
	jp   .anim
; --------------- frame #0 ---------------
; When visually switching to #1, use new damage info.
.obj0:
	mMvC_ValFrameEnd .anim ; About to advance the anim? If not, skip to .anim
	; Otherwise, request new damage fields to apply when visually switching frames
	mMvC_SetDamageNext $06, HITTYPE_HIT_MID0, PF3_HEAVYHIT
	jp   .anim
; --------------- common ---------------
.chkEnd:
	mMvC_ValFrameEnd .anim
	call Play_Pl_EndMove
	jr   .ret
.anim:
	jp   OBJLstS_DoAnimTiming_Loop_by_DE
.ret:
	ret
	
; =============== MoveC_Base_NormH_2Hit_D06_A04 ===============
; Generic move code used for heavy normals that hit twice.
MoveC_Base_NormH_2Hit_D06_A04:
	call Play_Pl_MoveByColiBoxOverlapX
	mMvC_ValLoaded .ret
	
	; Depending on the visible frame...
	ld   hl, iOBJInfo_OBJLstPtrTblOffsetView
	add  hl, de
	ld   a, [hl]		; A = OBJLst ID
	cp   $01*OBJLSTPTR_ENTRYSIZE
	jp   z, .obj1
; --------------- frame #0,2-(end) ---------------
	mMvC_ChkTarget .chkEnd
	jp   .anim
; --------------- frame #1 ---------------
; When visually switching to #2, use new damage info.
; Doing this allows the move to hit twice, since hitting the opponent removes
; the damage value for the move, to avoid multiple hits.
; So, if we hit the opponent before the the new damage gets applied (ie: pretty much always)
; the move will hit twice.
.obj1:
	mMvC_ValFrameEnd .anim ; About to advance the anim? If not, skip to .anim
	; Otherwise, request new damage fields to apply when visually switching frames
	mMvC_SetDamageNext $06, HITTYPE_HIT_MID1, PF3_HEAVYHIT
	jp   .anim
; --------------- common ---------------
.chkEnd:
	mMvC_ValFrameEnd .anim
	call Play_Pl_EndMove
	jr   .ret
.anim:
	jp   OBJLstS_DoAnimTiming_Loop_by_DE
.ret:
	ret
	
; =============== MoveC_MrBig_PunchH ===============
; Move code used for Mr.Big's heavy punch. 
; This is like MoveC_Base_NormH_2Hit_D06_A04, except the player moves
; forward 7px at the start of #0 and #1.
MoveC_MrBig_PunchH:
	call Play_Pl_MoveByColiBoxOverlapX
	mMvC_ValLoaded .ret
	
	; Depending on the visible frame...
	ld   hl, iOBJInfo_OBJLstPtrTblOffsetView
	add  hl, de
	ld   a, [hl]		; A = OBJLst ID
	cp   $00*OBJLSTPTR_ENTRYSIZE
	jp   z, .obj0
	cp   $01*OBJLSTPTR_ENTRYSIZE
	jp   z, .obj1
; --------------- frame #2-(end) ---------------
	mMvC_ChkTarget .chkEnd
	jp   .anim
; --------------- frame #0 ---------------
; The first time we get here, move 7px forward.
.obj0:
	mMvC_ValFrameStart .anim					; If not, jump
	mMvC_SetMoveH $0700
	jp   .anim
; --------------- frame #1 ---------------
.obj1:
	;
	; The first time we get here, move 7px forward.
	;
	mMvC_ValFrameStart .obj1_chkAdv			; If not, jump
	mMvC_SetMoveH $0700
.obj1_chkAdv:
	;
	; When visually switching to #2, use new damage info.
	;
	mMvC_ValFrameEnd .anim ; About to advance the anim? If not, skip to .anim
	; Otherwise, request new damage fields to apply when visually switching frames
	mMvC_SetDamageNext $06, HITTYPE_HIT_MID1, PF3_HEAVYHIT
	jp   .anim
; --------------- common ---------------	
.chkEnd:
	mMvC_ValFrameEnd .anim
	call Play_Pl_EndMove
	jr   .ret
.anim:
	jp   OBJLstS_DoAnimTiming_Loop_by_DE
.ret:
	ret
	
; =============== MoveC_Mature_PunchH ===============
; Move code used for Mature's heavy punch, this is almost the same
; as the one for Mr.Big's heavy punch, except for the logic of #0 being moved to #3,
; and different code to account for it.
;
; See also: MoveC_MrBig_PunchH
MoveC_Mature_PunchH:
	call Play_Pl_MoveByColiBoxOverlapX
	mMvC_ValLoaded .ret
	
	; Depending on the visible frame...
	ld   hl, iOBJInfo_OBJLstPtrTblOffsetView
	add  hl, de
	ld   a, [hl]
	cp   $01*OBJLSTPTR_ENTRYSIZE
	jp   z, .obj1
	cp   $03*OBJLSTPTR_ENTRYSIZE
	jp   z, .obj3
	
; --------------- frame #0,#2 ---------------
	; [POI] Could have been just "jp .anim". We get to .chkEnd anyway in #3
	mMvC_ChkTarget .chkEnd
	jp   .anim
; --------------- frame #3 ---------------
; The first time we get here, move 7px forward.
; When attempting to visually switch to #4, end the move instead.
.obj3:
	mMvC_ValFrameStart .obj3_chkAdv		; If not, jump
	mMvC_SetMoveH $0700				; Otherwise move forward
.obj3_chkAdv:
	;--
	; [POI] This is pointless, as .chkEnd checks it anyway.
	mMvC_ValFrameEnd .anim
	;--
	jp   .chkEnd
; --------------- frame #1 ---------------
.obj1:
	;
	; The first time we get here, move 7px forward.
	;
	mMvC_ValFrameStart .obj1_chkAdv
	mMvC_SetMoveH $0700
.obj1_chkAdv:
	;
	; When visually switching to #2, use new damage info.
	;
	mMvC_ValFrameEnd .anim ; About to advance the anim? If not, skip to .anim
	; Otherwise, request new damage fields to apply when visually switching frames
	mMvC_SetDamageNext $06, HITTYPE_HIT_MID1, PF3_HEAVYHIT
	jp   .anim
; --------------- common ---------------	
.chkEnd:
	mMvC_ValFrameEnd .anim
	call Play_Pl_EndMove
	jr   .ret
.anim:
	jp   OBJLstS_DoAnimTiming_Loop_by_DE
.ret:
	ret
	
; =============== MoveC_Goenitz_PunchH ===============
; Move code used for Goenitz's heavy punch, which hits 3 times.
;
; This is like Mature's heavy punch except for the extra hit on #4.
;
; See also: MoveC_Mature_PunchH	
MoveC_Goenitz_PunchH:
	call Play_Pl_MoveByColiBoxOverlapX
	mMvC_ValLoaded .ret
	
	; Depending on the visible frame...
	ld   hl, iOBJInfo_OBJLstPtrTblOffsetView
	add  hl, de
	ld   a, [hl]
	cp   $01*OBJLSTPTR_ENTRYSIZE
	jp   z, .obj1
	cp   $03*OBJLSTPTR_ENTRYSIZE
	jp   z, .obj3
	cp   $04*OBJLSTPTR_ENTRYSIZE
	jp   z, .obj4
; --------------- frame #0,#2,#5-(end) ---------------
	mMvC_ChkTarget .chkEnd
	jp   .anim
; --------------- frame #1 ---------------
.obj1:
	; The first time we get here, move 7px forward.
	mMvC_ValFrameStart .obj1_chkAdv
	mMvC_SetMoveH $0700
.obj1_chkAdv:
	; When visually switching to #2, use new damage info.
	mMvC_ValFrameEnd .anim ; About to advance the anim? If not, skip to .anim
	; Otherwise, request new damage fields to apply when visually switching frames
	mMvC_SetDamageNext $06, HITTYPE_HIT_MID1, $00
	jp   .anim
; --------------- frame #3 ---------------
.obj3:
	; The first time we get here, move 7px forward.
	mMvC_ValFrameStart .obj3_chkAdv
	mMvC_SetMoveH $0700
.obj3_chkAdv:
	; When visually switching to #2, use new damage info.
	mMvC_ValFrameEnd .anim ; About to advance the anim? If not, skip to .anim
	; Otherwise, request new damage fields to apply when visually switching frames
	mMvC_SetDamageNext $06, HITTYPE_HIT_MID0, PF3_HEAVYHIT
	jp   .anim
; --------------- frame #4 ---------------
.obj4:
	; The first time we get here, move 7px forward.
	mMvC_ValFrameStart .anim
	mMvC_SetMoveH $0700
	jp   .anim
; --------------- common ---------------
.chkEnd:
	mMvC_ValFrameEnd .anim
	call Play_Pl_EndMove
	jr   .ret
.anim:
	jp   OBJLstS_DoAnimTiming_Loop_by_DE
.ret:
	ret
	
; =============== MoveC_Goenitz_PunchH ===============
; Move code used for Goenitz's heavy kick, which hits 2 times.	
MoveC_Goenitz_KickH:
	call Play_Pl_MoveByColiBoxOverlapX
	mMvC_ValLoaded .ret
	
	; Depending on the visible frame...
	ld   hl, iOBJInfo_OBJLstPtrTblOffsetView
	add  hl, de
	ld   a, [hl]
	cp   $01*OBJLSTPTR_ENTRYSIZE
	jp   z, .obj1
	cp   $02*OBJLSTPTR_ENTRYSIZE
	jp   z, .obj2
; --------------- frame #0,#3-(end) ---------------
	mMvC_ChkTarget .chkEnd
	jp   .anim
; --------------- frame #1 ---------------
.obj1:
	; The first time we get here, move 7px forward.
	mMvC_ValFrameStart .anim
	mMvC_SetMoveH $0700
	jp   .anim
; --------------- frame #2 ---------------
.obj2:
	; The first time we get here, move 7px forward.
	mMvC_ValFrameStart .obj2_chkAdv
	mMvC_SetMoveH $0700
.obj2_chkAdv:
	mMvC_ValFrameEnd .anim ; About to advance the anim? If not, skip to .anim
	; Otherwise, request new damage fields to apply when visually switching frames
	mMvC_SetDamageNext $06, HITTYPE_HIT_MID1, PF3_HEAVYHIT
	jp   .anim
; --------------- common ---------------
.chkEnd:
	mMvC_ValFrameEnd .anim
	call Play_Pl_EndMove
	jr   .ret
.anim:
	jp   OBJLstS_DoAnimTiming_Loop_by_DE
.ret:
	ret
; =============== END OF BANK ===============
; Junk area below.
L1C7F4D: db $24;X
L1C7F4E: db $59;X
L1C7F4F: db $6F;X
L1C7F50: db $75;X
L1C7F51: db $20;X
L1C7F52: db $6E;X
L1C7F53: db $65;X
L1C7F54: db $76;X
L1C7F55: db $65;X
L1C7F56: db $72;X
L1C7F57: db $20;X
L1C7F58: db $68;X
L1C7F59: db $61;X
L1C7F5A: db $64;X
L1C7F5B: db $FF;X
L1C7F5C: db $20;X
L1C7F5D: db $61;X
L1C7F5E: db $20;X
L1C7F5F: db $63;X
L1C7F60: db $68;X
L1C7F61: db $61;X
L1C7F62: db $6E;X
L1C7F63: db $63;X
L1C7F64: db $65;X
L1C7F65: db $2C;X
L1C7F66: db $FF;X
L1C7F67: db $20;X
L1C7F68: db $20;X
L1C7F69: db $62;X
L1C7F6A: db $6C;X
L1C7F6B: db $6F;X
L1C7F6C: db $77;X
L1C7F6D: db $68;X
L1C7F6E: db $61;X
L1C7F6F: db $72;X
L1C7F70: db $64;X
L1C7F71: db $2E;X
L1C7F72: db $80;X
L1C7F73: db $99;X
L1C7F74: db $2F;X
L1C7F75: db $49;X
L1C7F76: db $60;X
L1C7F77: db $6D;X
L1C7F78: db $20;X
L1C7F79: db $66;X
L1C7F7A: db $69;X
L1C7F7B: db $67;X
L1C7F7C: db $68;X
L1C7F7D: db $74;X
L1C7F7E: db $69;X
L1C7F7F: db $6E;X
L1C7F80: db $67;X
L1C7F81: db $20;X
L1C7F82: db $6F;X
L1C7F83: db $6E;X
L1C7F84: db $FF;X
L1C7F85: db $20;X
L1C7F86: db $62;X
L1C7F87: db $65;X
L1C7F88: db $68;X
L1C7F89: db $61;X
L1C7F8A: db $6C;X
L1C7F8B: db $66;X
L1C7F8C: db $20;X
L1C7F8D: db $6F;X
L1C7F8E: db $66;X
L1C7F8F: db $FF;X
L1C7F90: db $20;X
L1C7F91: db $20;X
L1C7F92: db $74;X
L1C7F93: db $68;X
L1C7F94: db $65;X
L1C7F95: db $20;X
L1C7F96: db $6E;X
L1C7F97: db $61;X
L1C7F98: db $74;X
L1C7F99: db $75;X
L1C7F9A: db $72;X
L1C7F9B: db $61;X
L1C7F9C: db $6C;X
L1C7F9D: db $20;X
L1C7F9E: db $77;X
L1C7F9F: db $6F;X
L1C7FA0: db $72;X
L1C7FA1: db $6C;X
L1C7FA2: db $64;X
L1C7FA3: db $2E;X
L1C7FA4: db $6F;X
L1C7FA5: db $77;X
L1C7FA6: db $68;X
L1C7FA7: db $61;X
L1C7FA8: db $72;X
L1C7FA9: db $64;X
L1C7FAA: db $2E;X
L1C7FAB: db $80;X
L1C7FAC: db $99;X
L1C7FAD: db $2F;X
L1C7FAE: db $49;X
L1C7FAF: db $60;X
L1C7FB0: db $6D;X
L1C7FB1: db $20;X
L1C7FB2: db $66;X
L1C7FB3: db $69;X
L1C7FB4: db $67;X
L1C7FB5: db $68;X
L1C7FB6: db $74;X
L1C7FB7: db $69;X
L1C7FB8: db $6E;X
L1C7FB9: db $67;X
L1C7FBA: db $20;X
L1C7FBB: db $6F;X
L1C7FBC: db $6E;X
L1C7FBD: db $FF;X
L1C7FBE: db $20;X
L1C7FBF: db $62;X
L1C7FC0: db $65;X
L1C7FC1: db $68;X
L1C7FC2: db $61;X
L1C7FC3: db $6C;X
L1C7FC4: db $66;X
L1C7FC5: db $20;X
L1C7FC6: db $6F;X
L1C7FC7: db $66;X
L1C7FC8: db $FF;X
L1C7FC9: db $20;X
L1C7FCA: db $20;X
L1C7FCB: db $74;X
L1C7FCC: db $68;X
L1C7FCD: db $65;X
L1C7FCE: db $20;X
L1C7FCF: db $6E;X
L1C7FD0: db $61;X
L1C7FD1: db $74;X
L1C7FD2: db $75;X
L1C7FD3: db $72;X
L1C7FD4: db $61;X
L1C7FD5: db $6C;X
L1C7FD6: db $20;X
L1C7FD7: db $77;X
L1C7FD8: db $6F;X
L1C7FD9: db $72;X
L1C7FDA: db $6C;X
L1C7FDB: db $64;X
L1C7FDC: db $2E;X
L1C7FDD: db $61;X
L1C7FDE: db $6C;X
L1C7FDF: db $66;X
L1C7FE0: db $20;X
L1C7FE1: db $6F;X
L1C7FE2: db $66;X
L1C7FE3: db $FF;X
L1C7FE4: db $20;X
L1C7FE5: db $20;X
L1C7FE6: db $74;X
L1C7FE7: db $68;X
L1C7FE8: db $65;X
L1C7FE9: db $20;X
L1C7FEA: db $6E;X
L1C7FEB: db $61;X
L1C7FEC: db $74;X
L1C7FED: db $75;X
L1C7FEE: db $72;X
L1C7FEF: db $61;X
L1C7FF0: db $6C;X
L1C7FF1: db $20;X
L1C7FF2: db $77;X
L1C7FF3: db $6F;X
L1C7FF4: db $72;X
L1C7FF5: db $6C;X
L1C7FF6: db $64;X
L1C7FF7: db $2E;X
L1C7FF8: db $FF;X
L1C7FF9: db $FF;X
L1C7FFA: db $FF;X
L1C7FFB: db $FF;X
L1C7FFC: db $FF;X
L1C7FFD: db $FF;X
L1C7FFE: db $FF;X
L1C7FFF: db $FF;X
